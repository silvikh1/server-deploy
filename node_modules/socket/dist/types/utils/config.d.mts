import config from '@socketsecurity/config';
import type { CResult } from '../types.mts';
export interface LocalConfig {
    apiBaseUrl?: string | null | undefined;
    // @deprecated ; use apiToken. when loading a config, if this prop exists it
    //               is deleted and set to apiToken instead, and then persisted.
    //               should only happen once for legacy users.
    apiKey?: string | null | undefined;
    apiProxy?: string | null | undefined;
    apiToken?: string | null | undefined;
    defaultOrg?: string;
    enforcedOrgs?: string[] | readonly string[] | null | undefined;
    skipAskToPersistDefaultOrg?: boolean;
    org?: string; // convenience alias for defaultOrg
}
export declare const sensitiveConfigKeys: Set<keyof LocalConfig>;
export declare const supportedConfigKeys: Map<keyof LocalConfig, string>;
export declare function findSocketYmlSync(dir?: string): {
    path: string;
    parsed: config.SocketYml;
} | null;
export declare function getConfigValue<Key extends keyof LocalConfig>(key: Key): CResult<LocalConfig[Key]>;
// This version squashes errors, returning undefined instead.
// Should be used when we can reasonably predict the call can't fail.
export declare function getConfigValueOrUndef<Key extends keyof LocalConfig>(key: Key): LocalConfig[Key] | undefined;
export declare function isReadOnlyConfig(): boolean;
export declare function overrideCachedConfig(jsonConfig: unknown): CResult<undefined>;
export declare function overrideConfigApiToken(apiToken: unknown): void;
export declare function updateConfigValue<Key extends keyof LocalConfig>(configKey: keyof LocalConfig, value: LocalConfig[Key]): CResult<undefined | string>;
//# sourceMappingURL=config.d.mts.map