'use strict';

var vendor = require('./vendor.js');
var logger = require('../external/@socketsecurity/registry/lib/logger');
var debug = require('../external/@socketsecurity/registry/lib/debug');
var arrays = require('../external/@socketsecurity/registry/lib/arrays');
var objects = require('../external/@socketsecurity/registry/lib/objects');
var path$1 = require('../external/@socketsecurity/registry/lib/path');
var sorts = require('../external/@socketsecurity/registry/lib/sorts');
var constants = require('./constants.js');
var path = require('node:path');
var regexps = require('../external/@socketsecurity/registry/lib/regexps');
var prompts = require('../external/@socketsecurity/registry/lib/prompts');
var strings = require('../external/@socketsecurity/registry/lib/strings');
var promises = require('node:timers/promises');
var fs = require('node:fs');
var registry = require('../external/@socketsecurity/registry');
var packages = require('../external/@socketsecurity/registry/lib/packages');
var Module = require('node:module');
var spawn = require('../external/@socketsecurity/registry/lib/spawn');
var npm = require('../external/@socketsecurity/registry/lib/npm');
var words = require('../external/@socketsecurity/registry/lib/words');
var fs$1 = require('../external/@socketsecurity/registry/lib/fs');
var require$$7 = require('../external/@socketsecurity/registry/lib/promises');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
const {
  NPM: NPM$5,
  PNPM: PNPM$2
} = constants;
const PNPM_WORKSPACE = `${PNPM$2}-workspace`;
const ignoredDirs = [
// Taken from ignore-by-default:
// https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js
'.git',
// Git repository files, see <https://git-scm.com/>
'.log',
// Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
'.nyc_output',
// Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
'.sass-cache',
// Cache folder for node-sass, see <https://github.com/sass/node-sass>
'.yarn',
// Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
'bower_components',
// Where Bower packages are installed, see <http://bower.io/>
'coverage',
// Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
'node_modules',
// Where Node modules are installed, see <https://nodejs.org/>
// Taken from globby:
// https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16
'flow-typed'];
const ignoredDirPatterns = ignoredDirs.map(i => `**/${i}`);
async function getWorkspaceGlobs(agent, cwd = process.cwd()) {
  let workspacePatterns;
  if (agent === PNPM$2) {
    for (const workspacePath of [path.join(cwd, `${PNPM_WORKSPACE}.yaml`), path.join(cwd, `${PNPM_WORKSPACE}.yml`)]) {
      // eslint-disable-next-line no-await-in-loop
      const yml = await safeReadFile(workspacePath);
      if (yml) {
        try {
          workspacePatterns = vendor.distExports$1.parse(yml)?.packages;
        } catch {}
        if (workspacePatterns) {
          break;
        }
      }
    }
  } else {
    workspacePatterns = (await packages.readPackageJson(cwd, {
      throws: false
    }))?.['workspaces'];
  }
  return Array.isArray(workspacePatterns) ? workspacePatterns.filter(strings.isNonEmptyString).map(workspacePatternToGlobPattern) : [];
}
function ignoreFileLinesToGlobPatterns(lines, filepath, cwd) {
  const base = path.relative(cwd, path.dirname(filepath)).replace(/\\/g, '/');
  const patterns = [];
  for (let i = 0, {
      length
    } = lines; i < length; i += 1) {
    const pattern = lines[i].trim();
    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {
      patterns.push(ignorePatternToMinimatch(pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/ ? `!${path.posix.join(base, pattern.slice(1))}` : path.posix.join(base, pattern)));
    }
  }
  return patterns;
}
function ignoreFileToGlobPatterns(content, filepath, cwd) {
  return ignoreFileLinesToGlobPatterns(content.split(/\r?\n/), filepath, cwd);
}

// Based on `@eslint/compat` convertIgnorePatternToMinimatch.
// Apache v2.0 licensed
// Copyright Nicholas C. Zakas
// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28
function ignorePatternToMinimatch(pattern) {
  const isNegated = pattern.startsWith('!');
  const negatedPrefix = isNegated ? '!' : '';
  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd();
  // Special cases.
  if (patternToTest === '' || patternToTest === '**' || patternToTest === '/**' || patternToTest === '**') {
    return `${negatedPrefix}${patternToTest}`;
  }
  const firstIndexOfSlash = patternToTest.indexOf('/');
  const matchEverywherePrefix = firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1 ? '**/' : '';
  const patternWithoutLeadingSlash = firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest;
  // Escape `{` and `(` because in gitignore patterns they are just
  // literal characters without any specific syntactic meaning,
  // while in minimatch patterns they can form brace expansion or extglob syntax.
  //
  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.
  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.
  // Minimatch pattern `src/\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.
  const escapedPatternWithoutLeadingSlash = patternWithoutLeadingSlash.replaceAll(/(?=((?:\\.|[^{(])*))\1([{(])/guy, '$1\\$2');
  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : '';
  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`;
}
function workspacePatternToGlobPattern(workspace) {
  const {
    length
  } = workspace;
  if (!length) {
    return '';
  }
  // If the workspace ends with "/"
  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {
    return `${workspace}/*/package.json`;
  }
  // If the workspace ends with "/**"
  if (workspace.charCodeAt(length - 1) === 42 /*'*'*/ && workspace.charCodeAt(length - 2) === 42 /*'*'*/ && workspace.charCodeAt(length - 3) === 47 /*'/'*/) {
    return `${workspace}/*/**/package.json`;
  }
  // Things like "packages/a" or "packages/*"
  return `${workspace}/package.json`;
}
async function filterGlobResultToSupportedFiles(entries, supportedFiles) {
  const patterns = ['golang', NPM$5, 'maven', 'pypi', 'gem', 'nuget'].reduce((r, n) => {
    const supported = supportedFiles[n];
    r.push(...(supported ? Object.values(supported).map(p => `**/${p.pattern}`) : []));
    return r;
  }, []);
  return entries.filter(p => vendor.micromatchExports.some(p, patterns));
}
async function globWithGitIgnore(patterns, options) {
  const {
    cwd = process.cwd(),
    socketConfig,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const projectIgnorePaths = socketConfig?.projectIgnorePaths;
  const ignoreFiles = await vendor.distExports.glob(['**/.gitignore'], {
    absolute: true,
    cwd,
    expandDirectories: true
  });
  const ignores = [...ignoredDirPatterns, ...(Array.isArray(projectIgnorePaths) ? ignoreFileLinesToGlobPatterns(projectIgnorePaths, path.join(cwd, '.gitignore'), cwd) : []), ...(await Promise.all(ignoreFiles.map(async filepath => ignoreFileToGlobPatterns((await safeReadFile(filepath)) ?? '', filepath, cwd)))).flat()];
  const hasNegatedPattern = ignores.some(p => p.charCodeAt(0) === 33 /*'!'*/);
  const globOptions = {
    absolute: true,
    cwd,
    expandDirectories: false,
    ignore: hasNegatedPattern ? [] : ignores,
    ...additionalOptions
  };
  const result = await vendor.distExports.glob(patterns, globOptions);
  if (!hasNegatedPattern) {
    return result;
  }
  const {
    absolute
  } = globOptions;

  // Note: the input files must be INSIDE the cwd. If you get strange looking
  // relative path errors here, most likely your path is outside the given cwd.
  const filtered = vendor.ignoreExports().add(ignores).filter(absolute ? result.map(p => path.relative(cwd, p)) : result);
  return absolute ? filtered.map(p => path.resolve(cwd, p)) : filtered;
}
async function globNodeModules(cwd = process.cwd()) {
  return await vendor.distExports.glob('**/node_modules', {
    absolute: true,
    cwd,
    expandDirectories: false,
    onlyDirectories: true
  });
}
async function globWorkspace(agent, cwd = process.cwd()) {
  const workspaceGlobs = await getWorkspaceGlobs(agent, cwd);
  return workspaceGlobs.length ? await vendor.distExports.glob(workspaceGlobs, {
    absolute: true,
    cwd,
    ignore: ['**/node_modules/**', '**/bower_components/**']
  }) : [];
}
function pathsToGlobPatterns(paths) {
  // TODO: Does not support `~/` paths.
  return paths.map(p => p === '.' || p === './' ? '**/*' : p);
}

const {
  abortSignal
} = constants;
async function removeNodeModules(cwd = process.cwd()) {
  const nodeModulesPaths = await globNodeModules(cwd);
  await require$$7.pEach(nodeModulesPaths, 3, p => fs$1.remove(p, {
    force: true,
    recursive: true
  }), {
    retries: 3
  });
}
async function findUp(name, {
  cwd = process.cwd(),
  signal = abortSignal
}) {
  let dir = path.resolve(cwd);
  const {
    root
  } = path.parse(dir);
  const names = [name].flat();
  while (dir && dir !== root) {
    for (const name of names) {
      if (signal?.aborted) {
        return undefined;
      }
      const filePath = path.join(dir, name);
      try {
        // eslint-disable-next-line no-await-in-loop
        const stats = await fs.promises.stat(filePath);
        if (stats.isFile()) {
          return filePath;
        }
      } catch {}
    }
    dir = path.dirname(dir);
  }
  return undefined;
}
async function readFileBinary(filepath, options) {
  return await fs.promises.readFile(filepath, {
    signal: abortSignal,
    ...options,
    encoding: 'binary'
  });
}
async function readFileUtf8(filepath, options) {
  return await fs.promises.readFile(filepath, {
    signal: abortSignal,
    ...options,
    encoding: 'utf8'
  });
}
async function safeReadFile(filepath, options) {
  try {
    return await fs.promises.readFile(filepath, {
      encoding: 'utf8',
      signal: abortSignal,
      ...(typeof options === 'string' ? {
        encoding: options
      } : options)
    });
  } catch {}
  return undefined;
}
function safeReadFileSync(filepath, options) {
  try {
    return fs.readFileSync(filepath, {
      encoding: 'utf8',
      ...(typeof options === 'string' ? {
        encoding: options
      } : options)
    });
  } catch {}
  return undefined;
}
function safeStatsSync(filepath, options) {
  try {
    return fs.statSync(filepath, {
      throwIfNoEntry: false,
      ...options
    });
  } catch {}
  return undefined;
}

const sensitiveConfigKeys = new Set(['apiToken']);
const supportedConfigKeys = new Map([['apiBaseUrl', 'Base URL of the API endpoint'], ['apiProxy', 'A proxy through which to access the API'], ['apiToken', 'The API token required to access most API endpoints'], ['defaultOrg', 'The default org slug to use; usually the org your API token has access to. When set, all orgSlug arguments are implied to be this value.'], ['enforcedOrgs', 'Orgs in this list have their security policies enforced on this machine'], ['skipAskToPersistDefaultOrg', 'This flag prevents the CLI from asking you to persist the org slug when you selected one interactively'], ['org', 'Alias for defaultOrg']]);
function getConfigValues() {
  if (_cachedConfig === undefined) {
    // Order: env var > --config flag > file
    _cachedConfig = {};
    // Lazily access constants.socketAppDataPath.
    const {
      socketAppDataPath
    } = constants;
    if (socketAppDataPath) {
      const raw = safeReadFileSync(socketAppDataPath);
      if (raw) {
        try {
          Object.assign(_cachedConfig, JSON.parse(Buffer.from(raw, 'base64').toString()));
        } catch {
          logger.logger.warn(`Failed to parse config at ${socketAppDataPath}`);
        }
        // Normalize apiKey to apiToken and persist it.
        // This is a one time migration per user.
        if (_cachedConfig['apiKey']) {
          const token = _cachedConfig['apiKey'];
          delete _cachedConfig['apiKey'];
          updateConfigValue('apiToken', token);
        }
      } else {
        fs.mkdirSync(path.dirname(socketAppDataPath), {
          recursive: true
        });
      }
    }
  }
  return _cachedConfig;
}
function normalizeConfigKey(key) {
  // Note: apiKey was the old name of the token. When we load a config with
  //       property apiKey, we'll copy that to apiToken and delete the old property.
  // We added `org` as a convenience alias for `defaultOrg`
  const normalizedKey = key === 'apiKey' ? 'apiToken' : key === 'org' ? 'defaultOrg' : key;
  if (!supportedConfigKeys.has(normalizedKey)) {
    return {
      ok: false,
      message: `Invalid config key: ${normalizedKey}`,
      data: undefined
    };
  }
  return {
    ok: true,
    data: normalizedKey
  };
}
function findSocketYmlSync(dir = process.cwd()) {
  let prevDir = null;
  while (dir !== prevDir) {
    let ymlPath = path.join(dir, 'socket.yml');
    let yml = safeReadFileSync(ymlPath);
    if (yml === undefined) {
      ymlPath = path.join(dir, 'socket.yaml');
      yml = safeReadFileSync(ymlPath);
    }
    if (typeof yml === 'string') {
      try {
        return {
          path: ymlPath,
          parsed: vendor.configExports.parseSocketConfig(yml)
        };
      } catch {
        throw new Error(`Found file but was unable to parse ${ymlPath}`);
      }
    }
    prevDir = dir;
    dir = path.join(dir, '..');
  }
  return null;
}
function getConfigValue(key) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(key);
  if (!keyResult.ok) {
    return keyResult;
  }
  return {
    ok: true,
    data: localConfig[keyResult.data]
  };
}

// This version squashes errors, returning undefined instead.
// Should be used when we can reasonably predict the call can't fail.
function getConfigValueOrUndef(key) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(key);
  if (!keyResult.ok) {
    return undefined;
  }
  return localConfig[keyResult.data];
}
function isReadOnlyConfig() {
  return _readOnlyConfig;
}
let _cachedConfig;
// When using --config or SOCKET_CLI_CONFIG, do not persist the config.
let _readOnlyConfig = false;
function overrideCachedConfig(jsonConfig) {
  debug.debugFn('override: full config (not stored)');
  let config;
  try {
    config = JSON.parse(String(jsonConfig));
    if (!config || typeof config !== 'object') {
      // `null` is valid json, so are primitive values. They're not valid config objects :)
      return {
        ok: false,
        message: 'Could not parse Config as JSON',
        cause: "Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again."
      };
    }
  } catch {
    // Force set an empty config to prevent accidentally using system settings
    _cachedConfig = {};
    _readOnlyConfig = true;
    return {
      ok: false,
      message: 'Could not parse Config as JSON',
      cause: "Could not JSON parse the config override. Make sure it's a proper JSON object (double-quoted keys and strings, no unquoted `undefined`) and try again."
    };
  }

  // @ts-ignore Override an illegal object.
  _cachedConfig = config;
  _readOnlyConfig = true;

  // Normalize apiKey to apiToken
  if (_cachedConfig['apiKey']) {
    if (_cachedConfig['apiToken']) {
      logger.logger.warn('Note: The config override had both apiToken and apiKey. Using the apiToken value. Remove the apiKey to get rid of this message.');
    }
    _cachedConfig['apiToken'] = _cachedConfig['apiKey'];
    delete _cachedConfig['apiKey'];
  }
  return {
    ok: true,
    data: undefined
  };
}
function overrideConfigApiToken(apiToken) {
  debug.debugFn('override: API token (not stored)');

  // Set token to the local cached config and mark it read-only so it doesn't persist
  _cachedConfig = {
    ...vendor.configExports,
    ...(apiToken === undefined ? {} : {
      apiToken: String(apiToken)
    })
  };
  _readOnlyConfig = true;
}
let _pendingSave = false;
function updateConfigValue(configKey, value) {
  const localConfig = getConfigValues();
  const keyResult = normalizeConfigKey(configKey);
  if (!keyResult.ok) {
    return keyResult;
  }
  const key = keyResult.data;
  let wasDeleted = value === undefined; // implicitly when serializing
  if (key === 'skipAskToPersistDefaultOrg') {
    if (value === 'true' || value === 'false') {
      localConfig['skipAskToPersistDefaultOrg'] = value === 'true';
    } else {
      delete localConfig['skipAskToPersistDefaultOrg'];
      wasDeleted = true;
    }
  } else {
    if (value === 'undefined' || value === 'true' || value === 'false') {
      logger.logger.warn(`Note: The value is set to "${value}", as a string (!). Use \`socket config unset\` to reset a key.`);
    }
    localConfig[key] = value;
  }
  if (_readOnlyConfig) {
    return {
      ok: true,
      message: `Config key '${key}' was ${wasDeleted ? 'deleted' : `updated`}`,
      data: 'Change applied but not persisted; current config is overridden through env var or flag'
    };
  }
  if (!_pendingSave) {
    _pendingSave = true;
    process.nextTick(() => {
      _pendingSave = false;
      // Lazily access constants.socketAppDataPath.
      const {
        socketAppDataPath
      } = constants;
      if (socketAppDataPath) {
        fs.writeFileSync(socketAppDataPath, Buffer.from(JSON.stringify(localConfig)).toString('base64'));
      }
    });
  }
  return {
    ok: true,
    message: `Config key '${key}' was ${wasDeleted ? 'deleted' : `updated`}`,
    data: undefined
  };
}

const {
  kInternalsSymbol,
  [kInternalsSymbol]: {
    getSentry
  }
} = constants;
class AuthError extends Error {}
class InputError extends Error {
  constructor(message, body) {
    super(message);
    this.body = body;
  }
}
async function captureException(exception, hint) {
  const result = captureExceptionSync(exception, hint);
  // "Sleep" for a second, just in case, hopefully enough time to initiate fetch.
  await promises.setTimeout(1000);
  return result;
}
function captureExceptionSync(exception, hint) {
  const Sentry = getSentry();
  if (!Sentry) {
    return '';
  }
  debug.debugFn('send: exception to Sentry');
  return Sentry.captureException(exception, hint);
}

function failMsgWithBadge(badge, message) {
  const prefix = vendor.yoctocolorsCjsExports.bgRed(vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.white(` ${badge}${message ? ': ' : ''}`)));
  const postfix = message ? ` ${vendor.yoctocolorsCjsExports.bold(message)}` : '';
  return `${prefix}${postfix}`;
}

const TOKEN_PREFIX = 'sktsec_';
const {
  length: TOKEN_PREFIX_LENGTH
} = TOKEN_PREFIX;

// The API server that should be used for operations.
function getDefaultApiBaseUrl$1() {
  const baseUrl =
  // Lazily access constants.ENV.SOCKET_CLI_API_BASE_URL.
  constants.ENV.SOCKET_CLI_API_BASE_URL || getConfigValueOrUndef('apiBaseUrl');
  return isUrl(baseUrl) ? baseUrl : undefined;
}

// The API server that should be used for operations.
function getDefaultProxyUrl() {
  const apiProxy =
  // Lazily access constants.ENV.SOCKET_CLI_API_PROXY.
  constants.ENV.SOCKET_CLI_API_PROXY || getConfigValueOrUndef('apiProxy');
  return isUrl(apiProxy) ? apiProxy : undefined;
}
function isUrl(value) {
  if (strings.isNonEmptyString(value)) {
    try {
      // eslint-disable-next-line no-new
      new URL(value);
      return true;
    } catch {}
  }
  return false;
}

// This API key should be stored globally for the duration of the CLI execution.
let _defaultToken;
function getDefaultToken() {
  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.
  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {
    _defaultToken = undefined;
  } else {
    const key =
    // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN.
    constants.ENV.SOCKET_CLI_API_TOKEN || getConfigValueOrUndef('apiToken') || _defaultToken;
    _defaultToken = strings.isNonEmptyString(key) ? key : undefined;
  }
  return _defaultToken;
}
function getVisibleTokenPrefix() {
  const apiToken = getDefaultToken();
  return apiToken ? apiToken.slice(TOKEN_PREFIX_LENGTH, TOKEN_PREFIX_LENGTH + 5) : '';
}
function hasDefaultToken() {
  return !!getDefaultToken();
}
function getPublicToken() {
  return (
    // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN.
    (constants.ENV.SOCKET_CLI_API_TOKEN || getDefaultToken()) ??
    // Lazily access constants.SOCKET_PUBLIC_API_TOKEN.
    constants.SOCKET_PUBLIC_API_TOKEN
  );
}
async function setupSdk(apiToken = getDefaultToken(), apiBaseUrl = getDefaultApiBaseUrl$1(), proxy) {
  if (typeof apiToken !== 'string' && vendor.isInteractiveExports()) {
    apiToken = await prompts.password({
      message: 'Enter your Socket.dev API key (not saved, use socket login to persist)'
    });
    _defaultToken = apiToken;
  }
  if (!apiToken) {
    return {
      ok: false,
      message: 'Auth Error',
      cause: 'You need to provide an API Token. Run `socket login` first.'
    };
  }
  if (!isUrl(proxy)) {
    proxy = getDefaultProxyUrl();
  }
  const ProxyAgent = proxy?.startsWith('http:') ? vendor.HttpProxyAgent : vendor.HttpsProxyAgent;
  return {
    ok: true,
    data: new vendor.distExports$2.SocketSdk(apiToken, {
      agent: proxy ? new ProxyAgent({
        proxy
      }) : undefined,
      baseUrl: apiBaseUrl,
      userAgent: vendor.distExports$2.createUserAgentFromPkgJson({
        // Lazily access constants.ENV.INLINED_SOCKET_CLI_NAME.
        name: constants.ENV.INLINED_SOCKET_CLI_NAME,
        // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION.
        version: constants.ENV.INLINED_SOCKET_CLI_VERSION,
        // Lazily access constants.ENV.INLINED_SOCKET_CLI_HOMEPAGE.
        homepage: constants.ENV.INLINED_SOCKET_CLI_HOMEPAGE
      })
    })
  };
}

async function handleApiCall(value, fetchingDesc) {
  // Lazily access constants.spinner.
  const {
    spinner
  } = constants;
  spinner.start(`Requesting ${fetchingDesc} from API...`);
  let result;
  try {
    result = await value;

    // TODO: info, not success (looks weird when response is non-200)
    spinner.successAndStop(`Received API response (after requesting ${fetchingDesc}).`);
  } catch (e) {
    spinner.failAndStop(`An error was thrown while requesting ${fetchingDesc}`);
    const message = `${e || 'No error message returned'}`;
    const reason = `${e || 'No error message returned'}`;
    debug.debugFn(`catch: ${fetchingDesc} error:\n`, e);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${reason ? ` ( Reason: ${reason} )` : ''}`
    };
  } finally {
    spinner.stop();
  }

  // Note: TS can't narrow down the type of result due to generics
  if (result.success === false) {
    const err = result;
    const message = `${err.error || 'No error message returned'}`;
    const {
      cause: reason
    } = err;
    debug.debugFn(`fail: ${fetchingDesc} bad response:\n`, err);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${reason ? ` ( Reason: ${reason} )` : ''}`,
      data: {
        code: result.status
      }
    };
  } else {
    const ok = result;
    return {
      ok: true,
      data: ok.data
    };
  }
}
async function handleApiCallNoSpinner(value, description) {
  let result;
  try {
    result = await value;
  } catch (e) {
    const message = `${e || 'No error message returned'}`;
    const reason = `${e || 'No error message returned'}`;
    debug.debugFn(`catch: ${description} error:\n`, e);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${reason ? ` ( Reason: ${reason} )` : ''}`
    };
  }

  // Note: TS can't narrow down the type of result due to generics
  if (result.success === false) {
    const err = result;
    const message = `${err.error || 'No error message returned'}`;
    debug.debugFn(`fail: ${description} bad response:\n`, err);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${message}${err.cause ? ` ( Reason: ${err.cause} )` : ''}`,
      data: {
        code: result.status
      }
    };
  } else {
    const ok = result;
    return {
      ok: true,
      data: ok.data
    };
  }
}
async function getErrorMessageForHttpStatusCode(code) {
  if (code === 400) {
    return 'One of the options passed might be incorrect';
  }
  if (code === 403 || code === 401) {
    return 'Your API token may not have the required permissions for this command or you might be trying to access (data from) an organization that is not linked to the API key you are logged in with';
  }
  if (code === 404) {
    return 'The requested Socket API endpoint was not found (404) or there was no result for the requested parameters. If unexpected, this could be a temporary problem caused by an incident or a bug in the CLI. If the problem persists please let us know.';
  }
  if (code === 500) {
    return 'There was an unknown server side problem with your request. This ought to be temporary. Please let us know if this problem persists.';
  }
  return `Server responded with status code ${code}`;
}

// The API server that should be used for operations.
function getDefaultApiBaseUrl() {
  const baseUrl =
  // Lazily access constants.ENV.SOCKET_CLI_API_BASE_URL.
  constants.ENV.SOCKET_CLI_API_BASE_URL || getConfigValueOrUndef('apiBaseUrl');
  if (strings.isNonEmptyString(baseUrl)) {
    return baseUrl;
  }
  // Lazily access constants.API_V0_URL.
  const API_V0_URL = constants.API_V0_URL;
  return API_V0_URL;
}
async function queryApi(path, apiToken) {
  const baseUrl = getDefaultApiBaseUrl() || '';
  if (!baseUrl) {
    logger.logger.warn('API endpoint is not set and default was empty. Request is likely to fail.');
  }
  return await fetch(`${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiToken}:`)}`
    }
  });
}
async function queryApiSafeText(path, fetchSpinnerDesc) {
  const apiToken = getDefaultToken();
  if (!apiToken) {
    return {
      ok: false,
      message: 'Authentication Error',
      cause: 'User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.'
    };
  }

  // Lazily access constants.spinner.
  const {
    spinner
  } = constants;
  if (fetchSpinnerDesc) {
    spinner.start(`Requesting ${fetchSpinnerDesc} from API...`);
  }
  let result;
  try {
    result = await queryApi(path, apiToken);
    if (fetchSpinnerDesc) {
      spinner.successAndStop(`Received API response (after requesting ${fetchSpinnerDesc}).`);
    }
  } catch (e) {
    if (fetchSpinnerDesc) {
      spinner.failAndStop(`An error was thrown while requesting ${fetchSpinnerDesc}.`);
    }
    const cause = e?.message;
    debug.debugFn('catch: queryApi() error\n', e);
    return {
      ok: false,
      message: 'API Request failed to complete',
      ...(cause ? {
        cause
      } : {})
    };
  }
  if (!result.ok) {
    const cause = await getErrorMessageForHttpStatusCode(result.status);
    return {
      ok: false,
      message: 'Socket API returned an error',
      cause: `${result.statusText}${cause ? ` (cause: ${cause})` : ''}`
    };
  }
  try {
    const data = await result.text();
    return {
      ok: true,
      data
    };
  } catch (e) {
    debug.debugFn('catch: await result.text() error\n', e);
    return {
      ok: false,
      message: 'API Request failed to complete',
      cause: 'There was an unexpected error trying to read the response text'
    };
  }
}
async function queryApiSafeJson(path, fetchSpinnerDesc = '') {
  const result = await queryApiSafeText(path, fetchSpinnerDesc);
  if (!result.ok) {
    return result;
  }
  try {
    return {
      ok: true,
      data: JSON.parse(result.data)
    };
  } catch (e) {
    return {
      ok: false,
      message: 'Server returned invalid JSON',
      cause: `Please report this. JSON.parse threw an error over the following response: \`${(result.data?.slice?.(0, 100) || '<empty>').trim() + (result.data?.length > 100 ? '...' : '')}\``
    };
  }
}

function mdTableStringNumber(title1, title2, obj) {
  // | Date        | Counts |
  // | ----------- | ------ |
  // | Header      | 201464 |
  // | Paragraph   |     18 |
  let mw1 = title1.length;
  let mw2 = title2.length;
  for (const [key, value] of Object.entries(obj)) {
    mw1 = Math.max(mw1, key.length);
    mw2 = Math.max(mw2, String(value ?? '').length);
  }
  const lines = [];
  lines.push(`| ${title1.padEnd(mw1, ' ')} | ${title2.padEnd(mw2)} |`);
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`);
  for (const [key, value] of Object.entries(obj)) {
    lines.push(`| ${key.padEnd(mw1, ' ')} | ${String(value ?? '').padStart(mw2, ' ')} |`);
  }
  lines.push(`| ${'-'.repeat(mw1)} | ${'-'.repeat(mw2)} |`);
  return lines.join('\n');
}
function mdTable(logs,
// This is saying "an array of strings and the strings are a valid key of elements of T"
// In turn, T is defined above as the audit log event type from our OpenAPI docs.
cols, titles = cols) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length);
  for (const log of logs) {
    for (let i = 0, {
        length
      } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? '';
      cws[i] = Math.max(cws[i] ?? 0, String(val).length, (titles[i] || '').length);
    }
  }
  let div = '|';
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |';
  }
  let header = '|';
  for (let i = 0, {
      length
    } = titles; i < length; i += 1) {
    header += ' ' + String(titles[i]).padEnd(cws[i] ?? 0, ' ') + ' |';
  }
  let body = '';
  for (const log of logs) {
    body += '|';
    for (let i = 0, {
        length
      } = cols; i < length; i += 1) {
      // @ts-ignore
      const val = log[cols[i] ?? ''] ?? '';
      body += ' ' + String(val).padEnd(cws[i] ?? 0, ' ') + ' |';
    }
    body += '\n';
  }
  return [div, header, div, body.trim(), div].filter(s => !!s.trim()).join('\n');
}
function mdTableOfPairs(arr,
// This is saying "an array of strings and the strings are a valid key of elements of T"
// In turn, T is defined above as the audit log event type from our OpenAPI docs.
cols) {
  // Max col width required to fit all data in that column
  const cws = cols.map(col => col.length);
  for (const [key, val] of arr) {
    cws[0] = Math.max(cws[0] ?? 0, String(key).length);
    cws[1] = Math.max(cws[1] ?? 0, String(val ?? '').length);
  }
  let div = '|';
  for (const cw of cws) {
    div += ' ' + '-'.repeat(cw) + ' |';
  }
  let header = '|';
  for (let i = 0, {
      length
    } = cols; i < length; i += 1) {
    header += ' ' + String(cols[i]).padEnd(cws[i] ?? 0, ' ') + ' |';
  }
  let body = '';
  for (const [key, val] of arr) {
    body += '|';
    body += ' ' + String(key).padEnd(cws[0] ?? 0, ' ') + ' |';
    body += ' ' + String(val ?? '').padEnd(cws[1] ?? 0, ' ') + ' |';
    body += '\n';
  }
  return [div, header, div, body.trim(), div].filter(s => !!s.trim()).join('\n');
}

// Serialize the final result object before printing it
// All commands that support the --json flag should call this before printing
function serializeResultJson(data) {
  if (typeof data !== 'object' || !data) {
    process.exitCode = 1;
    debug.debugFn('typeof data=', typeof data);
    if (typeof data !== 'object' && data) {
      debug.debugFn('data:\n', data);
    }

    // We should not allow the json value to be "null", or a boolean/number/string,
    // even if they are valid "json".
    const message = 'There was a problem converting the data set to JSON. The JSON was not an object. Please try again without --json';
    return JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      data: message
    }).trim() + '\n';
  }
  try {
    return JSON.stringify(data, null, 2).trim() + '\n';
  } catch (e) {
    debug.debugFn('catch: unexpected\n', e);
    process.exitCode = 1;

    // This could be caused by circular references, which is an "us" problem
    const message = 'There was a problem converting the data set to JSON. Please try again without --json';
    logger.logger.fail(message);
    return JSON.stringify({
      ok: false,
      message: 'Unable to serialize JSON',
      data: message
    }).trim() + '\n';
  }
}

// TODO: not sure if I'm missing something but meow doesn't seem to expose this?

// Note: we use this description in getFlagListOutput, meow doesn't care

const commonFlags = {
  config: {
    type: 'string',
    default: '',
    hidden: true,
    description: 'Override the local config with this JSON'
  },
  dryRun: {
    type: 'boolean',
    default: false,
    hidden: true,
    // Only show in root command
    description: 'Do input validation for a command and exit 0 when input is ok'
  },
  help: {
    type: 'boolean',
    default: false,
    shortFlag: 'h',
    hidden: true,
    description: 'Print this help'
  },
  nobanner: {
    // I know this would be `--no-banner` but that doesn't work with cdxgen.
    // Mostly for internal usage anyways.
    type: 'boolean',
    default: false,
    hidden: true,
    description: 'Hide the Socket banner'
  },
  version: {
    type: 'boolean',
    hidden: true,
    description: 'Print the app version'
  }
};
const outputFlags = {
  json: {
    type: 'boolean',
    shortFlag: 'j',
    default: false,
    description: 'Output result as json'
  },
  markdown: {
    type: 'boolean',
    shortFlag: 'm',
    default: false,
    description: 'Output result as markdown'
  }
};

function checkCommandInput(outputKind, ...checks) {
  if (checks.every(d => d.test)) {
    return true;
  }
  const msg = ['Please review the input requirements and try again', ''];
  for (const d of checks) {
    // If nook, then ignore when test is ok
    if (d.nook && d.test) {
      continue;
    }
    const lines = d.message.split('\n');
    const {
      length: lineCount
    } = lines;
    if (!lineCount) {
      continue;
    }
    // If the message has newlines then format the first line with the input
    // expectation and the rest indented below it.
    msg.push(`  - ${lines[0]} (${d.test ? vendor.yoctocolorsCjsExports.green(d.pass) : vendor.yoctocolorsCjsExports.red(d.fail)})`);
    if (lineCount > 1) {
      msg.push(...lines.slice(1).map(str => `    ${str}`));
    }
    msg.push('');
  }

  // Use exit status of 2 to indicate incorrect usage, generally invalid
  // options or missing arguments.
  // https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html
  process.exitCode = 2;
  if (outputKind === 'json') {
    logger.logger.log(serializeResultJson({
      ok: false,
      message: 'Input error',
      data: msg.join('\n')
    }));
  } else {
    logger.logger.fail(failMsgWithBadge('Input error', msg.join('\n')));
  }
  return false;
}

function getOutputKind(json, markdown) {
  if (json) {
    return 'json';
  }
  if (markdown) {
    return 'markdown';
  }
  return 'text';
}

function getFlagListOutput(list, indent, {
  keyPrefix = '--',
  padName
} = {}) {
  return getHelpListOutput({
    ...list
  }, indent, {
    keyPrefix,
    padName
  });
}
function getHelpListOutput(list, indent, {
  keyPrefix = '',
  padName = 18
} = {}) {
  let result = '';
  const names = Object.keys(list).sort(sorts.naturalCompare);
  for (const name of names) {
    const entry = list[name];
    if (entry && 'hidden' in entry && entry?.hidden) {
      continue;
    }
    const description = (typeof entry === 'object' ? entry.description : entry) || '';
    result += ''.padEnd(indent) + (keyPrefix + name).padEnd(padName) + description + '\n';
  }
  return result.trim() || '(none)';
}

// Replace the start of a path with ~/ when it starts with your home dir.
// A common way to abbreviate the user home dir (though not strictly posix).
function tildify(cwd) {
  return cwd.replace(new RegExp(`^${regexps.escapeRegExp(constants.homePath)}(?:${path.sep}|$)`, 'i'), '~/');
}

async function meowWithSubcommands(subcommands, options) {
  const {
    aliases = {},
    argv,
    defaultSub,
    importMeta,
    name,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const [commandOrAliasName_, ...rawCommandArgv] = argv;
  let commandOrAliasName = commandOrAliasName_;
  if (!commandOrAliasName && defaultSub) {
    commandOrAliasName = defaultSub;
  }
  const flags = {
    ...commonFlags,
    ...additionalOptions.flags
  };

  // No further args or first arg is a flag (shrug)
  const isRootCommand = name === 'socket' && (!commandOrAliasName || commandOrAliasName?.startsWith('-'));

  // Try to support `socket <purl>` as a shorthand for `socket package score <purl>`
  if (!isRootCommand) {
    if (commandOrAliasName?.startsWith('pkg:')) {
      logger.logger.info('Note: Invoking `socket package score` now...');
      return await meowWithSubcommands(subcommands, {
        ...options,
        argv: ['package', 'deep', ...argv]
      });
    }
    // Support `socket npm/babel` or whatever as a shorthand, too.
    // Accept any ecosystem and let the remote sort it out.
    if (/^[a-z]+\//.test(commandOrAliasName || '')) {
      logger.logger.info('Note: Invoking `socket package score` now...');
      return await meowWithSubcommands(subcommands, {
        ...options,
        argv: ['package', 'deep', `pkg:${commandOrAliasName}`, ...rawCommandArgv]
      });
    }
  }
  if (isRootCommand) {
    flags['help'] = {
      type: 'boolean',
      hidden: false,
      // Only show on root
      description: 'Give you detailed help information about any sub-command'
    };
    flags['config'] = {
      type: 'string',
      hidden: false,
      // Only show on root
      description: 'Allows you to temp overrides the internal CLI config'
    };
    flags['dryRun'] = {
      type: 'boolean',
      hidden: false,
      // Only show on root
      description: 'Do input validation for a sub-command and then exit'
    };
    flags['version'] = {
      type: 'boolean',
      hidden: false,
      // Only show on root
      description: 'Show version of CLI'
    };
    delete flags['json'];
    delete flags['markdown'];
  } else {
    delete flags['help'];
    delete flags['version'];
  }

  // This is basically a dry-run parse of cli args and flags. We use this to
  // determine config overrides and expected output mode.
  const cli1 = vendor.meow(`(this should never be printed)`, {
    argv,
    importMeta,
    ...additionalOptions,
    flags,
    // Do not strictly check for flags here.
    allowUnknownFlags: true,
    booleanDefault: undefined,
    // We want to detect whether a bool flag is given at all.
    // We will emit help when we're ready
    // Plus, if we allow this then meow() can just exit here.
    autoHelp: false
  });
  const orgFlag = String(cli1.flags['org'] || '') || undefined;

  // Hard override the config if instructed to do so.
  // The env var overrides the --flag, which overrides the persisted config
  // Also, when either of these are used, config updates won't persist.
  let configOverrideResult;
  // Lazily access constants.ENV.SOCKET_CLI_CONFIG.
  if (constants.ENV.SOCKET_CLI_CONFIG) {
    configOverrideResult = overrideCachedConfig(
    // Lazily access constants.ENV.SOCKET_CLI_CONFIG.
    constants.ENV.SOCKET_CLI_CONFIG);
  } else if (cli1.flags['config']) {
    configOverrideResult = overrideCachedConfig(String(cli1.flags['config'] || ''));
  }

  // Lazily access constants.ENV.SOCKET_CLI_NO_API_TOKEN.
  if (constants.ENV.SOCKET_CLI_NO_API_TOKEN) {
    // This overrides the config override and even the explicit token env var.
    // The config will be marked as readOnly to prevent persisting it.
    overrideConfigApiToken(undefined);
  } else {
    // Lazily access constants.ENV.SOCKET_CLI_API_TOKEN.
    const tokenOverride = constants.ENV.SOCKET_CLI_API_TOKEN;
    if (tokenOverride) {
      // This will set the token (even if there was a config override) and
      // set it to readOnly, making sure the temp token won't be persisted.
      overrideConfigApiToken(tokenOverride);
    }
  }
  if (configOverrideResult?.ok === false) {
    emitBanner(name, orgFlag);
    logger.logger.error(''); // spacing in stderr
    logger.logger.fail(configOverrideResult.message);
    process.exitCode = 2;
    return;
  }

  // If we got at least some args, then lets find out if we can find a command.
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName];
    // First: Resolve argv data from alias if its an alias that's been given.
    const [commandName, ...commandArgv] = alias ? [...alias.argv, ...rawCommandArgv] : [commandOrAliasName, ...rawCommandArgv];
    // Second: Find a command definition using that data.
    const commandDefinition = commandName ? subcommands[commandName] : undefined;
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      });
    }
  }
  function formatCommandsForHelp(isRootCommand) {
    if (!isRootCommand) {
      return getHelpListOutput({
        ...objects.toSortedObject(Object.fromEntries(Object.entries(subcommands).filter(({
          1: subcommand
        }) => !subcommand.hidden))),
        ...objects.toSortedObject(Object.fromEntries(Object.entries(aliases).filter(({
          1: alias
        }) => {
          const {
            hidden
          } = alias;
          const cmdName = hidden ? '' : alias.argv[0];
          const subcommand = cmdName ? subcommands[cmdName] : undefined;
          return subcommand && !subcommand.hidden;
        })))
      }, 6);
    }

    // "Bucket" some commands for easier usage.
    const commands = new Set(['analytics', 'audit-log', 'config', 'fix', 'install', 'login', 'logout', 'manifest', 'npm', 'npx', 'optimize', 'organization', 'package', 'raw-npm', 'raw-npx', 'repos', 'scan', 'threat-feed', 'uninstall', 'wrapper']);
    Object.entries(subcommands).filter(([_name, subcommand]) => !subcommand.hidden).map(([name]) => name).forEach(name => {
      if (commands.has(name)) {
        commands.delete(name);
      } else {
        logger.logger.fail('Received a visible command that was not added to the list here:', name);
      }
    });
    if (commands.size) {
      logger.logger.fail('Found commands in the list that were not marked as public or not defined at all:',
      // Node < 22 will print 'Object (n)' before the array. So to have consistent
      // test snapshots we use joinAnd.
      arrays.joinAnd(Array.from(commands).sort(sorts.naturalCompare).map(c => `'${c}'`)));
    }
    const out = [];
    out.push('All commands have their own --help page');
    out.push('');
    out.push('    Main commands');
    out.push('');
    out.push('      socket login              Setup the CLI with an API Token and defaults');
    out.push('      socket scan create        Create a new Scan and report');
    out.push('      socket npm/eslint@1.0.0   Request the security score of a particular package');
    out.push('      socket ci                 Shorthand for CI; socket scan create --report --no-interactive');
    out.push('');
    out.push('    Socket API');
    out.push('');
    out.push('      analytics                 Look up analytics data');
    out.push('      audit-log                 Look up the audit log for an organization');
    out.push('      organization              Manage organization account details');
    out.push('      package                   Look up published package details');
    out.push('      repository                Manage registered repositories');
    out.push('      scan                      Manage Socket scans');
    out.push('      threat-feed               [beta] View the threat feed');
    out.push('');
    out.push('    Local tools');
    out.push('');
    out.push('      fix                       Update dependencies with "fixable" Socket alerts');
    out.push('      manifest                  Generate a dependency manifest for certain languages');
    out.push('      npm                       npm wrapper functionality');
    out.push('      npx                       npx wrapper functionality');
    out.push('      optimize                  Optimize dependencies with @socketregistry overrides');
    out.push('      raw-npm                   Temporarily disable the Socket npm wrapper');
    out.push('      raw-npx                   Temporarily disable the Socket npx wrapper');
    out.push('');
    out.push('    CLI configuration');
    out.push('');
    out.push('      config                    Manage the CLI configuration directly');
    out.push('      install                   Manually install CLI tab completion on your system');
    out.push('      login                     Socket API login and CLI setup');
    out.push('      logout                    Socket API logout');
    out.push('      uninstall                 Remove the CLI tab completion from your system');
    out.push('      wrapper                   Enable or disable the Socket npm/npx wrapper');
    return out.join('\n');
  }

  // Parse it again. Config overrides should now be applied (may affect help).
  // Note: this is displayed as help screen if the command does not override it
  //       (which is the case for most sub-commands with sub-commands)
  const cli2 = vendor.meow(`
    Usage
      $ ${name} <command>
${isRootCommand ? '' : '\n    Commands'}
      ${formatCommandsForHelp(isRootCommand)}

${isRootCommand ? '    Options' : '    Options'}${isRootCommand ? '       (Note: all CLI commands have these flags even when not displayed in their help)\n' : ''}
      ${getFlagListOutput(flags, 6, {
    padName: 25
  })}

    Examples
      $ ${name} --help
${isRootCommand ? `      $ ${name} scan create --json` : ''}${isRootCommand ? `\n      $ ${name} package score npm left-pad --markdown` : ''}`, {
    argv,
    importMeta,
    ...additionalOptions,
    flags,
    // Do not strictly check for flags here.
    allowUnknownFlags: true,
    // We will emit help when we're ready.
    // Plus, if we allow this then meow() can just exit here.
    autoHelp: false,
    // We want to detect whether a bool flag is given at all.
    booleanDefault: undefined
  });

  // ...else we provide basic instructions and help.
  if (!cli2.flags['nobanner']) {
    emitBanner(name, orgFlag);
    // meow will add newline so don't add stderr spacing here
  }
  if (!cli2.flags['help'] && cli2.flags['dryRun']) {
    process.exitCode = 0;
    // Lazily access constants.DRY_RUN_LABEL.
    logger.logger.log(`${constants.DRY_RUN_LABEL}: No-op, call a sub-command; ok`);
  } else {
    // When you explicitly request --help, the command should be successful
    // so we exit(0). If we do it because we need more input, we exit(2).
    cli2.showHelp(cli2.flags['help'] ? 0 : 2);
  }
}

/**
 * Note: meow will exit immediately if it calls its .showHelp()
 */
function meowOrExit({
  argv,
  config,
  importMeta,
  parentName
}) {
  const command = `${parentName} ${config.commandName}`;

  // This exits if .printHelp() is called either by meow itself or by us.
  const cli = vendor.meow({
    argv,
    autoHelp: false,
    // meow will exit(0) before printing the banner.
    booleanDefault: undefined,
    // We want to detect whether a bool flag is given at all.
    collectUnknownFlags: true,
    description: config.description,
    flags: config.flags,
    help: config.help(command, config),
    importMeta
  });
  if (!cli.flags['nobanner']) {
    emitBanner(command, String(cli.flags['org'] || '') || undefined);
    // Add spacing in stderr. meow.help adds a newline too so we do it here
    logger.logger.error('');
  }

  // As per https://github.com/sindresorhus/meow/issues/178
  // Setting `allowUnknownFlags: false` makes it reject camel cased flags.
  // if (!allowUnknownFlags) {
  //   // Run meow specifically with the flag setting. It will exit(2) if an
  //   // invalid flag is set and print a message.
  //   meow({
  //     argv,
  //     allowUnknownFlags: false,
  //     autoHelp: false,
  //     description: config.description,
  //     flags: config.flags,
  //     help: config.help(command, config),
  //     importMeta,
  //   })
  // }

  if (cli.flags['help']) {
    cli.showHelp(0);
  }
  // Now test for help state. Run meow again. If it exits now, it must be due
  // to wanting to print the help screen. But it would exit(0) and we want a
  // consistent exit(2) for that case (missing input). TODO: move away from meow
  process.exitCode = 2;
  vendor.meow({
    argv,
    description: config.description,
    help: config.help(command, config),
    importMeta,
    flags: config.flags,
    // As per https://github.com/sindresorhus/meow/issues/178
    // Setting `allowUnknownFlags: false` makes it reject camel cased flags.
    // allowUnknownFlags: Boolean(allowUnknownFlags),
    autoHelp: false
  });
  // Ok, no help, reset to default.
  process.exitCode = 0;
  return cli;
}
function emitBanner(name, orgFlag) {
  // Print a banner at the top of each command.
  // This helps with brand recognition and marketing.
  // It also helps with debugging since it contains version and command details.
  // Note: print over stderr to preserve stdout for flags like --json and
  //       --markdown. If we don't do this, you can't use --json in particular
  //       and pipe the result to other tools. By emitting the banner over stderr
  //       you can do something like `socket scan view xyz | jq | process`.
  //       The spinner also emits over stderr for example.
  logger.logger.error(getAsciiHeader(name, orgFlag));
}
function getAsciiHeader(command, orgFlag) {
  // Note: In tests we return <redacted> because otherwise snapshots will fail.
  const {
    REDACTED
  } = constants;
  // Lazily access constants.ENV.VITEST.
  const redacting = constants.ENV.VITEST;
  const cliVersion = redacting ? REDACTED :
  // Lazily access constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH.
  constants.ENV.INLINED_SOCKET_CLI_VERSION_HASH;
  const nodeVersion = redacting ? REDACTED : process.version;
  const defaultOrg = getConfigValueOrUndef('defaultOrg');
  const readOnlyConfig = isReadOnlyConfig() ? '*' : '.';
  const shownToken = redacting ? REDACTED : getVisibleTokenPrefix() || '(not set)';
  const relCwd = redacting ? REDACTED : path$1.normalizePath(tildify(process.cwd()));
  // Note: we must redact org when creating snapshots because dev machine probably
  //       has a default org set but CI won't. Showing --org is fine either way.
  const orgPart = orgFlag ? `--org: ${orgFlag}` : redacting ? 'org: <redacted>' : defaultOrg ? `default org: ${defaultOrg}` : '(org not set)';
  // Note: We could draw these with ascii box art instead but I worry about
  //       portability and paste-ability. "simple" ascii chars just work.
  const body = `
   _____         _       _        /---------------
  |   __|___ ___| |_ ___| |_      | Socket.dev CLI ver ${cliVersion}
  |__   | ${readOnlyConfig} |  _| '_| -_|  _|     | Node: ${nodeVersion}, API token: ${shownToken}, ${orgPart}
  |_____|___|___|_,_|___|_|.dev   | Command: \`${command}\`, cwd: ${relCwd}
  `.trim();
  return `   ${body}`; // Note: logger will auto-append a newline
}

function msAtHome(isoTimeStamp) {
  const timeStart = Date.parse(isoTimeStamp);
  const timeEnd = Date.now();
  const rtf = new Intl.RelativeTimeFormat('en', {
    numeric: 'always',
    style: 'short'
  });
  const delta = timeEnd - timeStart;
  if (delta < 60 * 60 * 1000) {
    return rtf.format(-Math.round(delta / (60 * 1000)), 'minute');
    // return Math.round(delta / (60 * 1000)) + ' min ago'
  } else if (delta < 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (60 * 60 * 1000)).toFixed(1), 'hour');
    // return (delta / (60 * 60 * 1000)).toFixed(1) + ' hr ago'
  } else if (delta < 7 * 24 * 60 * 60 * 1000) {
    return rtf.format(-(delta / (24 * 60 * 60 * 1000)).toFixed(1), 'day');
    // return (delta / (24 * 60 * 60 * 1000)).toFixed(1) + ' day ago'
  } else {
    return isoTimeStamp.slice(0, 10);
  }
}

async function suggestOrgSlug() {
  const sockSdkResult = await setupSdk();
  if (!sockSdkResult.ok) {
    return;
  }
  const sockSdk = sockSdkResult.data;
  const result = await handleApiCall(sockSdk.getOrganizations(), 'list of organizations');

  // Ignore a failed request here. It was not the primary goal of
  // running this command and reporting it only leads to end-user confusion.
  if (result.ok) {
    const proceed = await prompts.select({
      message: 'Missing org name; do you want to use any of these orgs for this scan?',
      choices: [...Object.values(result.data.organizations).map(org => {
        const name = org.name ?? org.slug;
        return {
          name: `Yes [${name}]`,
          value: name,
          description: `Use "${name}" as the organization`
        };
      }), {
        name: 'No',
        value: '',
        description: 'Do not use any of these organizations (will end in a no-op)'
      }]
    });
    if (proceed === undefined) {
      return undefined;
    }
    if (proceed) {
      return proceed;
    }
  } else {
    logger.logger.fail('Failed to lookup organization list from API, unable to suggest');
  }
}

async function suggestToPersistOrgSlug(orgSlug) {
  const skipAsk = getConfigValue('skipAskToPersistDefaultOrg');
  if (!skipAsk.ok || skipAsk.data) {
    // Don't ask to store it when disabled before, or when reading config fails.
    return;
  }
  const result = await prompts.select({
    message: `Would you like to use this org (${orgSlug}) as the default org for future calls?`,
    choices: [{
      name: 'Yes',
      value: 'yes',
      description: 'Stores it in your config'
    }, {
      name: 'No',
      value: 'no',
      description: 'Do not persist this org as default org'
    }, {
      name: "No and don't ask again",
      value: 'sush',
      description: 'Do not store as default org and do not ask again to persist it'
    }]
  });
  if (result === 'yes') {
    const updateResult = updateConfigValue('defaultOrg', orgSlug);
    if (updateResult.ok) {
      logger.logger.success('Updated default org config to:', orgSlug);
    } else {
      logger.logger.fail('(Non blocking) Failed to update default org in config:', updateResult.cause);
    }
  } else if (result === 'sush') {
    const updateResult = updateConfigValue('skipAskToPersistDefaultOrg', true);
    if (updateResult.ok) {
      logger.logger.info('Default org not changed. Will not ask to persist again.');
    } else {
      logger.logger.fail(`(Non blocking) Failed to store preference; will ask to persist again next time. Reason: ${updateResult.cause}`);
    }
  }
}

async function determineOrgSlug(orgFlag, interactive, dryRun) {
  const defaultOrgSlug = getConfigValueOrUndef('defaultOrg');
  let orgSlug = String(orgFlag || defaultOrgSlug || '');
  if (!orgSlug) {
    if (!interactive) {
      logger.logger.warn('Note: This command requires an org slug because the remote API endpoint does.');
      logger.logger.warn('');
      logger.logger.warn('It seems no default org was setup and the `--org` flag was not used.');
      logger.logger.warn("Additionally, `--no-interactive` was set so we can't ask for it.");
      logger.logger.warn('Since v1.0.0 the org _argument_ for all commands was dropped in favor of an');
      logger.logger.warn('implicit default org setting, which will be setup when you run `socket login`.');
      logger.logger.warn('');
      logger.logger.warn('Note: When running in CI, you probably want to set the `--org` flag.');
      logger.logger.warn('');
      logger.logger.warn('For details, see: https://docs.socket.dev/docs/v1-migration-guide');
      logger.logger.warn('');
      logger.logger.warn('This command will exit now because the org slug is required to proceed.');
      return ['', undefined];
    }

    // ask from server
    logger.logger.warn('Unable to determine the target org. Trying to auto-discover it now...');
    logger.logger.info('Note: you can run `socket login` to set a default org. You can also override it with the --org flag.');
    logger.logger.error(''); // spacing in stderr
    if (dryRun) {
      logger.logger.fail('Skipping auto-discovery of org in dry-run mode');
    } else {
      orgSlug = (await suggestOrgSlug()) || '';
      if (orgSlug) {
        await suggestToPersistOrgSlug(orgSlug);
      }
    }
  }
  return [orgSlug, defaultOrgSlug];
}

function getPurlObject(purl) {
  return typeof purl === 'string' ? vendor.packageurlJsExports.PackageURL.fromString(purl) : purl;
}

const {
  SOCKET_WEBSITE_URL
} = constants;
function getPkgFullNameFromPurl(purl) {
  const purlObj = getPurlObject(purl);
  const {
    name,
    namespace
  } = purlObj;
  return namespace ? `${namespace}${purlObj.type === 'maven' ? ':' : '/'}${name}` : name;
}
function getSocketDevPackageOverviewUrlFromPurl(purl) {
  const purlObj = getPurlObject(purl);
  const fullName = getPkgFullNameFromPurl(purlObj);
  return getSocketDevPackageOverviewUrl(purlObj.type, fullName, purlObj.version);
}
function getSocketDevPackageOverviewUrl(ecosystem, fullName, version) {
  const url = `${SOCKET_WEBSITE_URL}/${ecosystem}/package/${fullName}`;
  return ecosystem === 'golang' ? `${url}${version ? `?section=overview&version=${version}` : ''}` : `${url}${version ? `/overview/${version}` : ''}`;
}

/**
 * Convert a Map<string, Map|string> to a nested object of similar shape.
 * The goal is to serialize it with JSON.stringify, which Map can't do.
 */
function mapToObject(map) {
  return Object.fromEntries(Array.from(map.entries()).map(([k, v]) => [k, v instanceof Map ? mapToObject(v) : v]));
}

function* walkNestedMap(map, keys = []) {
  for (const [key, value] of map.entries()) {
    if (value instanceof Map) {
      yield* walkNestedMap(value, keys.concat(key));
    } else {
      yield {
        keys: keys.concat(key),
        value: value
      };
    }
  }
}

const {
  NODE_MODULES: NODE_MODULES$1,
  NPM: NPM$4,
  shadowBinPath
} = constants;
function findBinPathDetailsSync(binName) {
  const binPaths = vendor.libExports$1.sync(binName, {
    all: true,
    nothrow: true
  }) ?? [];
  let shadowIndex = -1;
  let theBinPath;
  for (let i = 0, {
      length
    } = binPaths; i < length; i += 1) {
    const binPath = binPaths[i];
    // Skip our bin directory if it's in the front.
    if (path.dirname(binPath) === shadowBinPath) {
      shadowIndex = i;
    } else {
      theBinPath = npm.resolveBinPathSync(binPath);
      break;
    }
  }
  return {
    name: binName,
    path: theBinPath,
    shadowed: shadowIndex !== -1
  };
}
function findNpmPathSync(npmBinPath) {
  // Lazily access constants.WIN32.
  const {
    WIN32
  } = constants;
  let thePath = npmBinPath;
  while (true) {
    const libNmNpmPath = path.join(thePath, 'lib', NODE_MODULES$1, NPM$4);
    // mise puts its npm bin in a path like:
    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/bin/npm.
    // HOWEVER, the location of the npm install is:
    //   /Users/SomeUsername/.local/share/mise/installs/node/vX.X.X/lib/node_modules/npm.
    if (
    // Use existsSync here because statsSync, even with { throwIfNoEntry: false },
    // will throw an ENOTDIR error for paths like ./a-file-that-exists/a-directory-that-does-not.
    // See https://github.com/nodejs/node/issues/56993.
    fs.existsSync(libNmNpmPath) && safeStatsSync(libNmNpmPath)?.isDirectory()) {
      thePath = path.join(libNmNpmPath, NPM$4);
    }
    const nmPath = path.join(thePath, NODE_MODULES$1);
    if (
    // npm bin paths may look like:
    //   /usr/local/share/npm/bin/npm
    //   /Users/SomeUsername/.nvm/versions/node/vX.X.X/bin/npm
    //   C:\Users\SomeUsername\AppData\Roaming\npm\bin\npm.cmd
    // OR
    //   C:\Program Files\nodejs\npm.cmd
    //
    // In practically all cases the npm path contains a node_modules folder:
    //   /usr/local/share/npm/bin/npm/node_modules
    //   C:\Program Files\nodejs\node_modules
    fs.existsSync(nmPath) && safeStatsSync(nmPath)?.isDirectory() && (
    // Optimistically look for the default location.
    path.basename(thePath) === NPM$4 ||
    // Chocolatey installs npm bins in the same directory as node bins.
    WIN32 && fs.existsSync(path.join(thePath, `${NPM$4}.cmd`)))) {
      return thePath;
    }
    const parent = path.dirname(thePath);
    if (parent === thePath) {
      return undefined;
    }
    thePath = parent;
  }
}
async function getPackageFilesForScan(cwd, inputPaths, supportedFiles, config) {
  debug.debugFn(`resolve: ${inputPaths.length} paths`, inputPaths);

  // Lazily access constants.spinner.
  const {
    spinner
  } = constants;
  const patterns = pathsToGlobPatterns(inputPaths);
  spinner.start('Searching for local files to include in scan...');
  const entries = await globWithGitIgnore(patterns, {
    cwd,
    socketConfig: config
  });
  if (debug.isDebug()) {
    spinner.stop();
    debug.debugFn(`Resolved ${inputPaths.length} paths to ${entries.length} local paths:\n`, entries);
    spinner.start('Searching for files now...');
  } else {
    spinner.start(`Resolved ${inputPaths.length} paths to ${entries.length} local paths, searching for files now...`);
  }
  const packageFiles = await filterGlobResultToSupportedFiles(entries, supportedFiles);
  spinner.successAndStop(`Found ${packageFiles.length} local ${words.pluralize('file', packageFiles.length)}`);
  debug.debugFn('paths: absolute', packageFiles);
  return packageFiles;
}

async function readOrDefaultSocketJson(cwd) {
  const result = await readSocketJson(cwd, true);
  if (result.ok) {
    return result.data;
  }
  // This should be unreachable but it makes TS happy
  return getDefaultSocketJson();
}
function getDefaultSocketJson() {
  return {
    ' _____         _       _     ': 'Local config file for Socket CLI tool ( https://npmjs.org/socket ), to work with https://socket.dev',
    '|   __|___ ___| |_ ___| |_   ': '     The config in this file is used to set as defaults for flags or command args when using the CLI',
    "|__   | . |  _| '_| -_|  _|  ": '     in this dir, often a repo root. You can choose commit or .ignore this file, both works.',
    '|_____|___|___|_,_|___|_|.dev': 'Warning: This file may be overwritten without warning by `socket manifest setup` or other commands',
    version: 1
  };
}
async function readSocketJson(cwd, defaultOnError = false) {
  const sockJsonPath = path.join(cwd, 'socket.json');
  if (!fs.existsSync(sockJsonPath)) {
    debug.debugFn(`miss: file not found ${sockJsonPath}`);
    return {
      ok: true,
      data: getDefaultSocketJson()
    };
  }
  let json = null;
  try {
    json = await fs.promises.readFile(sockJsonPath, 'utf8');
  } catch (e) {
    debug.debugLog('[DEBUG] Raw error:');
    debug.debugLog(e);
    if (defaultOnError) {
      logger.logger.warn('Warning: failed to read file, using default');
      return {
        ok: true,
        data: getDefaultSocketJson()
      };
    }
    const msg = e?.message || '(none)';
    return {
      ok: false,
      message: 'Failed to read file',
      cause: `An error was thrown while trying to read your socket.json: ${msg}`
    };
  }
  let obj;
  try {
    obj = JSON.parse(json);
  } catch {
    debug.debugFn('fail: parse JSON\n', json);
    if (defaultOnError) {
      logger.logger.warn('Warning: failed to parse file, using default');
      return {
        ok: true,
        data: getDefaultSocketJson()
      };
    }
    return {
      ok: false,
      message: 'Failed to parse socket.json',
      cause: 'socket.json does not contain valid JSON, please verify'
    };
  }
  if (!obj) {
    logger.logger.warn('Warning: file contents was empty, using default');
    return {
      ok: true,
      data: getDefaultSocketJson()
    };
  }

  // Do we really care to validate? All properties are optional so code will have
  // to check every step of the way regardless. Who cares about validation here...?

  return {
    ok: true,
    data: obj
  };
}
async function writeSocketJson(cwd, sockJson) {
  let json = '';
  try {
    json = JSON.stringify(sockJson, null, 2);
  } catch (e) {
    debug.debugFn('fail: stringify JSON\n', e);
    debug.debugLog('[DEBUG] Object:\n', sockJson);
    return {
      ok: false,
      message: 'Failed to serialize to JSON',
      cause: 'There was an unexpected problem converting the socket json object to a JSON string. Unable to store it.'
    };
  }
  const filepath = path.join(cwd, 'socket.json');
  await fs.promises.writeFile(filepath, json + '\n', 'utf8');
  return {
    ok: true,
    data: undefined
  };
}

const {
  NODE_MODULES,
  NPM: NPM$3,
  NPX,
  SOCKET_CLI_ISSUES_URL
} = constants;
function exitWithBinPathError(binName) {
  logger.logger.fail(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable`);
  // The exit code 127 indicates that the command or binary being executed
  // could not be found.
  // eslint-disable-next-line n/no-process-exit
  process.exit(127);
}
let _npmBinPathDetails;
function getNpmBinPathDetails() {
  if (_npmBinPathDetails === undefined) {
    _npmBinPathDetails = findBinPathDetailsSync(NPM$3);
  }
  return _npmBinPathDetails;
}
let _npxBinPathDetails;
function getNpxBinPathDetails() {
  if (_npxBinPathDetails === undefined) {
    _npxBinPathDetails = findBinPathDetailsSync(NPX);
  }
  return _npxBinPathDetails;
}
function isNpmBinPathShadowed() {
  return getNpmBinPathDetails().shadowed;
}
function isNpxBinPathShadowed() {
  return getNpxBinPathDetails().shadowed;
}
let _npmBinPath;
function getNpmBinPath() {
  if (_npmBinPath === undefined) {
    _npmBinPath = getNpmBinPathDetails().path;
    if (!_npmBinPath) {
      exitWithBinPathError(NPM$3);
    }
  }
  return _npmBinPath;
}
let _npmPath;
function getNpmPath() {
  if (_npmPath === undefined) {
    const npmBinPath = getNpmBinPath();
    _npmPath = npmBinPath ? findNpmPathSync(npmBinPath) : undefined;
    if (!_npmPath) {
      let message = 'Unable to find npm CLI install directory.';
      if (npmBinPath) {
        message += `\nSearched parent directories of ${path.dirname(npmBinPath)}.`;
      }
      message += `\n\nThis is may be a bug with socket-npm related to changes to the npm CLI.\nPlease report to ${SOCKET_CLI_ISSUES_URL}.`;
      logger.logger.fail(message);
      // The exit code 127 indicates that the command or binary being executed
      // could not be found.
      // eslint-disable-next-line n/no-process-exit
      process.exit(127);
    }
  }
  return _npmPath;
}
let _npmRequire;
function getNpmRequire() {
  if (_npmRequire === undefined) {
    const npmPath = getNpmPath();
    const npmNmPath = path.join(npmPath, NODE_MODULES, NPM$3);
    _npmRequire = Module.createRequire(path.join(fs.existsSync(npmNmPath) ? npmNmPath : npmPath, '<dummy-basename>'));
  }
  return _npmRequire;
}
let _npxBinPath;
function getNpxBinPath() {
  if (_npxBinPath === undefined) {
    _npxBinPath = getNpxBinPathDetails().path;
    if (!_npxBinPath) {
      exitWithBinPathError(NPX);
    }
  }
  return _npxBinPath;
}

const {
  ALERT_TYPE_CRITICAL_CVE,
  ALERT_TYPE_CVE,
  ALERT_TYPE_MEDIUM_CVE,
  ALERT_TYPE_MILD_CVE
} = constants;
function isArtifactAlertCve(alert) {
  const {
    type
  } = alert;
  return type === ALERT_TYPE_CVE || type === ALERT_TYPE_MEDIUM_CVE || type === ALERT_TYPE_MILD_CVE || type === ALERT_TYPE_CRITICAL_CVE;
}

function createEnum(obj) {
  return Object.freeze({
    __proto__: null,
    ...obj
  });
}

const ALERT_FIX_TYPE = createEnum({
  cve: 'cve',
  remove: 'remove',
  upgrade: 'upgrade'
});

const ALERT_SEVERITY = createEnum({
  critical: 'critical',
  high: 'high',
  middle: 'middle',
  low: 'low'
});

class ColorOrMarkdown {
  constructor(useMarkdown) {
    this.useMarkdown = !!useMarkdown;
  }
  bold(text) {
    return this.useMarkdown ? `**${text}**` : vendor.yoctocolorsCjsExports.bold(`${text}`);
  }
  header(text, level = 1) {
    return this.useMarkdown ? `\n${''.padStart(level, '#')} ${text}\n` : vendor.yoctocolorsCjsExports.underline(`\n${level === 1 ? vendor.yoctocolorsCjsExports.bold(text) : text}\n`);
  }
  hyperlink(text, url, {
    fallback = true,
    fallbackToUrl
  } = {}) {
    if (url) {
      return this.useMarkdown ? `[${text}](${url})` : vendor.terminalLinkExports(text, url, {
        fallback: fallbackToUrl ? (_text, url) => url : fallback
      });
    }
    return text;
  }
  indent(...args) {
    return vendor.indentStringExports(...args);
  }
  italic(text) {
    return this.useMarkdown ? `_${text}_` : vendor.yoctocolorsCjsExports.italic(`${text}`);
  }
  json(value) {
    return this.useMarkdown ? '```json\n' + JSON.stringify(value) + '\n```' : JSON.stringify(value);
  }
  list(items) {
    const indentedContent = items.map(item => this.indent(item).trimStart());
    return this.useMarkdown ? `* ${indentedContent.join('\n* ')}\n` : `${indentedContent.join('\n')}\n`;
  }
}

const RangeStyles = ['caret', 'gt', 'gte', 'lt', 'lte', 'pin', 'preserve', 'tilde'];
function applyRange(refRange, version, style = 'preserve') {
  switch (style) {
    case 'caret':
      return `^${version}`;
    case 'gt':
      return `>${version}`;
    case 'gte':
      return `>=${version}`;
    case 'lt':
      return `<${version}`;
    case 'lte':
      return `<=${version}`;
    case 'preserve':
      {
        const range = new vendor.semverExports.Range(refRange);
        const {
          raw
        } = range;
        const comparators = range.set.flat();
        const {
          length
        } = comparators;
        if (length === 1) {
          const char = /^[<>]=?/.exec(raw)?.[0];
          if (char) {
            return `${char}${version}`;
          }
        } else if (length === 2) {
          const char = /^[~^]/.exec(raw)?.[0];
          if (char) {
            return `${char}${version}`;
          }
        }
        return version;
      }
    case 'tilde':
      return `~${version}`;
    case 'pin':
    default:
      return version;
  }
}
function getMajor(version) {
  try {
    const coerced = vendor.semverExports.coerce(version);
    return coerced ? vendor.semverExports.major(coerced) : null;
  } catch {}
  return null;
}
function getMinVersion(range) {
  try {
    return vendor.semverExports.minVersion(range);
  } catch {}
  return null;
}

const require$1 =Module.createRequire(require('u' + 'rl').pathToFileURL(__filename).href)
let _translations;
function getTranslations() {
  if (_translations === undefined) {
    _translations = require$1(
    // Lazily access constants.rootPath.
    path.join(constants.rootPath, 'translations.json'));
  }
  return _translations;
}

const ALERT_SEVERITY_COLOR = createEnum({
  critical: 'magenta',
  high: 'red',
  middle: 'yellow',
  low: 'white'
});
const ALERT_SEVERITY_ORDER = createEnum({
  critical: 0,
  high: 1,
  middle: 2,
  low: 3,
  none: 4
});
const MIN_ABOVE_THE_FOLD_COUNT = 3;
const MIN_ABOVE_THE_FOLD_ALERT_COUNT = 1;
const format = new ColorOrMarkdown(false);
function getHiddenRiskCounts(hiddenAlerts) {
  const riskCounts = {
    critical: 0,
    high: 0,
    middle: 0,
    low: 0
  };
  for (const alert of hiddenAlerts) {
    switch (getAlertSeverityOrder(alert)) {
      case ALERT_SEVERITY_ORDER.critical:
        riskCounts.critical += 1;
        break;
      case ALERT_SEVERITY_ORDER.high:
        riskCounts.high += 1;
        break;
      case ALERT_SEVERITY_ORDER.middle:
        riskCounts.middle += 1;
        break;
      case ALERT_SEVERITY_ORDER.low:
        riskCounts.low += 1;
        break;
    }
  }
  return riskCounts;
}
function getHiddenRisksDescription(riskCounts) {
  const descriptions = [];
  if (riskCounts.critical) {
    descriptions.push(`${riskCounts.critical} ${getSeverityLabel('critical')}`);
  }
  if (riskCounts.high) {
    descriptions.push(`${riskCounts.high} ${getSeverityLabel('high')}`);
  }
  if (riskCounts.middle) {
    descriptions.push(`${riskCounts.middle} ${getSeverityLabel('middle')}`);
  }
  if (riskCounts.low) {
    descriptions.push(`${riskCounts.low} ${getSeverityLabel('low')}`);
  }
  return `(${descriptions.join('; ')})`;
}
async function addArtifactToAlertsMap(artifact, alertsByPurl, options) {
  // Make TypeScript happy.
  if (!artifact.name || !artifact.version || !artifact.alerts?.length) {
    return alertsByPurl;
  }
  const {
    consolidate = false,
    include: _include,
    overrides
  } = {
    __proto__: null,
    ...options
  };
  const socketYml = findSocketYmlSync();
  const localRules = socketYml?.parsed.issueRules;
  const include = {
    __proto__: null,
    blocked: true,
    critical: true,
    cve: true,
    unfixable: true,
    upgradable: false,
    ..._include
  };
  const name = packages.resolvePackageName(artifact);
  const {
    type: ecosystem,
    version
  } = artifact;
  const enabledState = {
    __proto__: null,
    ...localRules
  };
  let sockPkgAlerts = [];
  for (const alert of artifact.alerts) {
    const action = alert.action ?? '';
    const enabledFlag = enabledState[alert.type];
    if (action === 'ignore' && enabledFlag !== true || enabledFlag === false) {
      continue;
    }
    const blocked = action === 'error';
    const critical = alert.severity === ALERT_SEVERITY.critical;
    const cve = isArtifactAlertCve(alert);
    const fixType = alert.fix?.type ?? '';
    const fixableCve = fixType === ALERT_FIX_TYPE.cve;
    const fixableUpgrade = fixType === ALERT_FIX_TYPE.upgrade;
    const fixable = fixableCve || fixableUpgrade;
    const upgradable = fixableUpgrade && !objects.hasOwn(overrides, name);
    if (include.blocked && blocked || include.critical && critical || include.cve && cve || include.unfixable && !fixable || include.upgradable && upgradable) {
      sockPkgAlerts.push({
        name,
        version,
        key: alert.key,
        type: alert.type,
        blocked,
        critical,
        ecosystem,
        fixable,
        raw: alert,
        upgradable
      });
    }
  }
  if (!sockPkgAlerts.length) {
    return alertsByPurl;
  }
  const purl = `pkg:${ecosystem}/${name}@${version}`;
  const major = getMajor(version);
  if (consolidate) {
    const highestForCve = new Map();
    const highestForUpgrade = new Map();
    const unfixableAlerts = [];
    for (const sockPkgAlert of sockPkgAlerts) {
      const alert = sockPkgAlert.raw;
      const fixType = alert.fix?.type ?? '';
      if (fixType === ALERT_FIX_TYPE.cve) {
        // An alert with alert.fix.type of 'cve' should have a
        // alert.props.firstPatchedVersionIdentifier property value.
        // We're just being cautious.
        const firstPatchedVersionIdentifier = alert.props?.firstPatchedVersionIdentifier;
        const patchedMajor = firstPatchedVersionIdentifier ? getMajor(firstPatchedVersionIdentifier) : null;
        if (typeof patchedMajor === 'number') {
          // Consolidate to the highest "first patched version" by each major
          // version number.
          const highest = highestForCve.get(patchedMajor)?.version ?? '0.0.0';
          if (vendor.semverExports.gt(firstPatchedVersionIdentifier, highest)) {
            highestForCve.set(patchedMajor, {
              alert: sockPkgAlert,
              version: firstPatchedVersionIdentifier
            });
          }
        } else {
          unfixableAlerts.push(sockPkgAlert);
        }
      } else if (fixType === ALERT_FIX_TYPE.upgrade) {
        // For Socket Optimize upgrades we assume the highest version available
        // is compatible. This may change in the future.
        const highest = highestForUpgrade.get(major)?.version ?? '0.0.0';
        if (vendor.semverExports.gt(version, highest)) {
          highestForUpgrade.set(major, {
            alert: sockPkgAlert,
            version
          });
        }
      } else {
        unfixableAlerts.push(sockPkgAlert);
      }
    }
    sockPkgAlerts = [
    // Sort CVE alerts by severity: critical, high, middle, then low.
    ...Array.from(highestForCve.values()).map(d => d.alert).sort(alertSeverityComparator), ...Array.from(highestForUpgrade.values()).map(d => d.alert), ...unfixableAlerts];
  } else {
    sockPkgAlerts.sort((a, b) => sorts.naturalCompare(a.type, b.type));
  }
  if (sockPkgAlerts.length) {
    alertsByPurl.set(purl, sockPkgAlerts);
  }
  return alertsByPurl;
}
function alertsHaveBlocked(alerts) {
  return alerts.find(a => a.blocked) !== undefined;
}
function alertsHaveSeverity(alerts, severity) {
  return alerts.find(a => a.raw.severity === severity) !== undefined;
}
function alertSeverityComparator(a, b) {
  // Put the most severe first.
  return getAlertSeverityOrder(a) - getAlertSeverityOrder(b);
}
function getAlertSeverityOrder(alert) {
  // The more severe, the lower the sort number.
  const {
    severity
  } = alert.raw;
  return severity === ALERT_SEVERITY.critical ? 0 : severity === ALERT_SEVERITY.high ? 1 : severity === ALERT_SEVERITY.middle ? 2 : severity === ALERT_SEVERITY.low ? 3 : 4;
}
function getAlertsSeverityOrder(alerts) {
  return alertsHaveBlocked(alerts) || alertsHaveSeverity(alerts, ALERT_SEVERITY.critical) ? 0 : alertsHaveSeverity(alerts, ALERT_SEVERITY.high) ? 1 : alertsHaveSeverity(alerts, ALERT_SEVERITY.middle) ? 2 : alertsHaveSeverity(alerts, ALERT_SEVERITY.low) ? 3 : 4;
}
function getCveInfoFromAlertsMap(alertsMap, options_) {
  const options = {
    __proto__: null,
    exclude: undefined,
    limit: Infinity,
    ...options_
  };
  options.exclude = {
    __proto__: null,
    ...options.exclude
  };
  let count = 0;
  let infoByPartialPurl = null;
  alertsMapLoop: for (const {
    0: purl,
    1: sockPkgAlerts
  } of alertsMap) {
    const purlObj = getPurlObject(purl);
    const partialPurl = new vendor.packageurlJsExports$1.PackageURL(purlObj.type, purlObj.namespace, purlObj.name).toString();
    const name = packages.resolvePackageName(purlObj);
    sockPkgAlertsLoop: for (const sockPkgAlert of sockPkgAlerts) {
      const alert = sockPkgAlert.raw;
      if (alert.fix?.type !== ALERT_FIX_TYPE.cve || options.exclude.upgradable && registry.getManifestData(sockPkgAlert.ecosystem, name)) {
        continue sockPkgAlertsLoop;
      }
      if (!infoByPartialPurl) {
        infoByPartialPurl = new Map();
      }
      let infos = infoByPartialPurl.get(partialPurl);
      if (!infos) {
        infos = new Map();
        infoByPartialPurl.set(partialPurl, infos);
      }
      const {
        key
      } = alert;
      if (!infos.has(key)) {
        // An alert with alert.fix.type of 'cve' should have a
        // alert.props.firstPatchedVersionIdentifier property value.
        // We're just being cautious.
        const firstPatchedVersionIdentifier = alert.props?.firstPatchedVersionIdentifier;
        const vulnerableVersionRange = alert.props?.vulnerableVersionRange;
        let error;
        if (firstPatchedVersionIdentifier && vulnerableVersionRange) {
          try {
            infos.set(key, {
              firstPatchedVersionIdentifier,
              vulnerableVersionRange: new vendor.semverExports.Range(
              // Replace ', ' in a range like '>= 1.0.0, < 1.8.2' with ' ' so that
              // semver.Range will parse it without erroring.
              vulnerableVersionRange.replace(/, +/g, ' ').replace(/; +/g, ' || ')).format()
            });
            if (++count >= options.limit) {
              break alertsMapLoop;
            }
            continue sockPkgAlertsLoop;
          } catch (e) {
            error = e;
          }
        }
        debug.debugFn('fail: invalid SocketPackageAlert\n', alert);
        if (error) {
          // Explicitly use debugLog here.
          debug.debugLog(error.message ?? error);
        }
      }
    }
  }
  return infoByPartialPurl;
}
function getSeverityLabel(severity) {
  return severity === 'middle' ? 'moderate' : severity;
}
function logAlertsMap(alertsMap, options) {
  const {
    hideAt = 'middle',
    output = process.stderr
  } = {
    __proto__: null,
    ...options
  };
  const translations = getTranslations();
  const sortedEntries = Array.from(alertsMap.entries()).sort((a, b) => getAlertsSeverityOrder(a[1]) - getAlertsSeverityOrder(b[1]));
  const aboveTheFoldPurls = new Set();
  const viewableAlertsByPurl = new Map();
  const hiddenAlertsByPurl = new Map();
  for (let i = 0, {
      length
    } = sortedEntries; i < length; i += 1) {
    const {
      0: purl,
      1: alerts
    } = sortedEntries[i];
    const hiddenAlerts = [];
    const viewableAlerts = alerts.filter(a => {
      const keep = a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER[hideAt];
      if (!keep) {
        hiddenAlerts.push(a);
      }
      return keep;
    });
    if (hiddenAlerts.length) {
      hiddenAlertsByPurl.set(purl, hiddenAlerts.sort(alertSeverityComparator));
    }
    if (!viewableAlerts.length) {
      continue;
    }
    viewableAlerts.sort(alertSeverityComparator);
    viewableAlertsByPurl.set(purl, viewableAlerts);
    if (viewableAlerts.find(a => a.blocked || getAlertSeverityOrder(a) < ALERT_SEVERITY_ORDER.middle)) {
      aboveTheFoldPurls.add(purl);
    }
  }

  // If MIN_ABOVE_THE_FOLD_COUNT is NOT met add more from viewable pkg ids.
  for (const {
    0: purl
  } of viewableAlertsByPurl.entries()) {
    if (aboveTheFoldPurls.size >= MIN_ABOVE_THE_FOLD_COUNT) {
      break;
    }
    aboveTheFoldPurls.add(purl);
  }
  // If MIN_ABOVE_THE_FOLD_COUNT is STILL NOT met add more from hidden pkg ids.
  for (const {
    0: purl,
    1: hiddenAlerts
  } of hiddenAlertsByPurl.entries()) {
    if (aboveTheFoldPurls.size >= MIN_ABOVE_THE_FOLD_COUNT) {
      break;
    }
    aboveTheFoldPurls.add(purl);
    const viewableAlerts = viewableAlertsByPurl.get(purl) ?? [];
    if (viewableAlerts.length < MIN_ABOVE_THE_FOLD_ALERT_COUNT) {
      const neededCount = MIN_ABOVE_THE_FOLD_ALERT_COUNT - viewableAlerts.length;
      let removedHiddenAlerts;
      if (hiddenAlerts.length - neededCount > 0) {
        removedHiddenAlerts = hiddenAlerts.splice(0, MIN_ABOVE_THE_FOLD_ALERT_COUNT);
      } else {
        removedHiddenAlerts = hiddenAlerts;
        hiddenAlertsByPurl.delete(purl);
      }
      viewableAlertsByPurl.set(purl, [...viewableAlerts, ...removedHiddenAlerts]);
    }
  }
  const mentionedPurlsWithHiddenAlerts = new Set();
  for (let i = 0, prevAboveTheFold = true, entries = Array.from(viewableAlertsByPurl.entries()), {
      length
    } = entries; i < length; i += 1) {
    const {
      0: purl,
      1: alerts
    } = entries[i];
    const lines = new Set();
    for (const alert of alerts) {
      const {
        type
      } = alert;
      const severity = alert.raw.severity ?? '';
      const attributes = [...(severity ? [vendor.yoctocolorsCjsExports[ALERT_SEVERITY_COLOR[severity]](getSeverityLabel(severity))] : []), ...(alert.blocked ? [vendor.yoctocolorsCjsExports.bold(vendor.yoctocolorsCjsExports.red('blocked'))] : []), ...(alert.fixable ? ['fixable'] : [])];
      const maybeAttributes = attributes.length ? ` ${vendor.yoctocolorsCjsExports.italic(`(${attributes.join('; ')})`)}` : '';
      // Based data from { pageProps: { alertTypes } } of:
      // https://socket.dev/_next/data/94666139314b6437ee4491a0864e72b264547585/en-US.json
      const info = translations.alerts[type];
      const title = info?.title ?? type;
      const maybeDesc = info?.description ? ` - ${info.description}` : '';
      const content = `${title}${maybeAttributes}${maybeDesc}`;
      // TODO: emoji seems to mis-align terminals sometimes
      lines.add(`  ${content}`);
    }
    const purlObj = getPurlObject(purl);
    const pkgName = packages.resolvePackageName(purlObj);
    const hyperlink = format.hyperlink(pkgName, getSocketDevPackageOverviewUrl(purlObj.type, pkgName, purlObj.version));
    const isAboveTheFold = aboveTheFoldPurls.has(purl);
    if (isAboveTheFold) {
      aboveTheFoldPurls.add(purl);
      output.write(`${i ? '\n' : ''}${hyperlink}:\n`);
    } else {
      output.write(`${prevAboveTheFold ? '\n' : ''}${hyperlink}:\n`);
    }
    for (const line of lines) {
      output.write(`${line}\n`);
    }
    const hiddenAlerts = hiddenAlertsByPurl.get(purl) ?? [];
    const {
      length: hiddenAlertsCount
    } = hiddenAlerts;
    if (hiddenAlertsCount) {
      mentionedPurlsWithHiddenAlerts.add(purl);
      if (hiddenAlertsCount === 1) {
        output.write(`  ${vendor.yoctocolorsCjsExports.dim(`+1 Hidden ${getSeverityLabel(hiddenAlerts[0].raw.severity ?? 'low')} risk alert`)}\n`);
      } else {
        output.write(`  ${vendor.yoctocolorsCjsExports.dim(`+${hiddenAlertsCount} Hidden alerts ${vendor.yoctocolorsCjsExports.italic(getHiddenRisksDescription(getHiddenRiskCounts(hiddenAlerts)))}`)}\n`);
      }
    }
    prevAboveTheFold = isAboveTheFold;
  }
  const additionalHiddenCount = hiddenAlertsByPurl.size - mentionedPurlsWithHiddenAlerts.size;
  if (additionalHiddenCount) {
    const totalRiskCounts = {
      critical: 0,
      high: 0,
      middle: 0,
      low: 0
    };
    for (const {
      0: purl,
      1: alerts
    } of hiddenAlertsByPurl.entries()) {
      if (mentionedPurlsWithHiddenAlerts.has(purl)) {
        continue;
      }
      const riskCounts = getHiddenRiskCounts(alerts);
      totalRiskCounts.critical += riskCounts.critical;
      totalRiskCounts.high += riskCounts.high;
      totalRiskCounts.middle += riskCounts.middle;
      totalRiskCounts.low += riskCounts.low;
    }
    output.write(`${aboveTheFoldPurls.size ? '\n' : ''}${vendor.yoctocolorsCjsExports.dim(`${aboveTheFoldPurls.size ? '+' : ''}${additionalHiddenCount} Packages with hidden alerts ${vendor.yoctocolorsCjsExports.italic(getHiddenRisksDescription(totalRiskCounts))}`)}\n`);
  }
  output.write('\n');
}

function idToNpmPurl(id) {
  return `pkg:npm/${id}`;
}
function idToPurl(id, type) {
  return `pkg:${type}/${id}`;
}

function extractOverridesFromPnpmLockSrc(lockfileContent) {
  return typeof lockfileContent === 'string' ? /^overrides:(\r?\n {2}.+)+(?:\r?\n)*/m.exec(lockfileContent)?.[0] ?? '' : '';
}
async function extractPurlsFromPnpmLockfile(lockfile) {
  const packages = lockfile?.packages ?? {};
  const seen = new Set();
  const visit = pkgPath => {
    if (seen.has(pkgPath)) {
      return;
    }
    const pkg = packages[pkgPath];
    if (!pkg) {
      return;
    }
    seen.add(pkgPath);
    const deps = {
      __proto__: null,
      ...pkg.dependencies,
      ...pkg.optionalDependencies,
      ...pkg.devDependencies
    };
    for (const depName in deps) {
      const ref = deps[depName];
      const subKey = isPnpmDepPath(ref) ? ref : `/${depName}@${ref}`;
      visit(subKey);
    }
  };
  for (const pkgPath of Object.keys(packages)) {
    visit(pkgPath);
  }
  return Array.from(seen).map(p => idToNpmPurl(stripPnpmPeerSuffix(stripLeadingPnpmDepPathSlash(p))));
}
function isPnpmDepPath(maybeDepPath) {
  return maybeDepPath.length > 0 && maybeDepPath.charCodeAt(0) === 47; /*'/'*/
}
function parsePnpmLockfile(lockfileContent) {
  let result;
  if (typeof lockfileContent === 'string') {
    try {
      result = vendor.jsYaml.load(strings.stripBom(lockfileContent));
    } catch {}
  }
  return objects.isObjectObject(result) ? result : null;
}
function parsePnpmLockfileVersion(version) {
  try {
    return vendor.semverExports.coerce(version);
  } catch {}
  return null;
}
function stripLeadingPnpmDepPathSlash(depPath) {
  return isPnpmDepPath(depPath) ? depPath.slice(1) : depPath;
}
function stripPnpmPeerSuffix(depPath) {
  const parenIndex = depPath.indexOf('(');
  const index = parenIndex === -1 ? depPath.indexOf('_') : parenIndex;
  return index === -1 ? depPath : depPath.slice(0, index);
}

async function getAlertsMapFromPnpmLockfile(lockfile, options) {
  const purls = await extractPurlsFromPnpmLockfile(lockfile);
  return await getAlertsMapFromPurls(purls, {
    overrides: lockfile.overrides,
    ...options
  });
}
async function getAlertsMapFromPurls(purls, options_) {
  const options = {
    __proto__: null,
    consolidate: false,
    include: undefined,
    nothrow: false,
    ...options_
  };
  options.include = {
    __proto__: null,
    // Leave 'actions' unassigned so it can be given a default value in
    // subsequent functions where `options` is passed.
    // actions: undefined,
    blocked: true,
    critical: true,
    cve: true,
    existing: false,
    unfixable: true,
    upgradable: false,
    ...options.include
  };
  const {
    spinner
  } = options;
  const uniqPurls = arrays.arrayUnique(purls);
  debug.debugFn('inspect:', {
    purls: uniqPurls
  });
  let {
    length: remaining
  } = uniqPurls;
  const alertsByPurl = new Map();
  if (!remaining) {
    return alertsByPurl;
  }
  const getText = () => `Looking up data for ${remaining} packages`;
  spinner?.start(getText());
  const sockSdkResult = await setupSdk(getPublicToken());
  if (!sockSdkResult.ok) {
    spinner?.stop();
    throw new Error('Auth error: Try to run `socket login` first');
  }
  const sockSdk = sockSdkResult.data;
  const alertsMapOptions = {
    overrides: options.overrides,
    consolidate: options.consolidate,
    include: options.include,
    spinner
  };
  for await (const batchResult of sockSdk.batchPackageStream({
    alerts: 'true',
    compact: 'true',
    ...(options.include.actions ? {
      actions: options.include.actions.join(',')
    } : {}),
    ...(options.include.unfixable ? {} : {
      fixable: 'true'
    })
  }, {
    components: uniqPurls.map(purl => ({
      purl
    }))
  })) {
    if (batchResult.success) {
      await addArtifactToAlertsMap(batchResult.data, alertsByPurl, alertsMapOptions);
    } else if (!options.nothrow) {
      const statusCode = batchResult.status ?? 'unknown';
      const statusMessage = batchResult.error ?? 'No status message';
      throw new Error(`Socket API server error (${statusCode}): ${statusMessage}`);
    } else {
      spinner?.stop();
      logger.logger.fail(`Received a ${batchResult.status} response from Socket API which we consider a permanent failure:`, batchResult.error, batchResult.cause ? `( ${batchResult.cause} )` : '');
      debug.debugFn('inspect:', {
        batchResult
      });
      break;
    }
    remaining -= 1;
    if (remaining > 0) {
      spinner?.start(getText());
    }
  }
  spinner?.stop();
  return alertsByPurl;
}

function npa(...args) {
  try {
    return Reflect.apply(vendor.npaExports, undefined, args);
  } catch {}
  return null;
}

async function readLockfile(lockfilePath) {
  return fs.existsSync(lockfilePath) ? await readFileUtf8(lockfilePath) : null;
}

const helpFlags = new Set(['--help', '-h']);
function cmdFlagsToString(args) {
  const result = [];
  for (let i = 0, {
      length
    } = args; i < length; i += 1) {
    if (args[i].startsWith('--')) {
      // Check if the next item exists and is NOT another flag.
      if (i + 1 < length && !args[i + 1].startsWith('--')) {
        result.push(`${args[i]}=${args[i + 1]}`);
        i += 1;
      } else {
        result.push(args[i]);
      }
    }
  }
  return result.join(' ');
}
function cmdFlagValueToArray(flagValue) {
  if (typeof flagValue === 'string') {
    return flagValue.trim().split(/, */);
  }
  if (Array.isArray(flagValue)) {
    return flagValue.flatMap(v => v.split(/, */));
  }
  return [];
}
function cmdPrefixMessage(cmdName, text) {
  const cmdPrefix = cmdName ? `${cmdName}: ` : '';
  return `${cmdPrefix}${text}`;
}
function isHelpFlag(cmdArg) {
  return helpFlags.has(cmdArg);
}

const {
  NPM: NPM$2,
  SOCKET_CLI_SAFE_BIN,
  SOCKET_CLI_SAFE_PROGRESS,
  SOCKET_IPC_HANDSHAKE
} = constants;
function safeNpmInstall(options) {
  const {
    agentExecPath = getNpmBinPath(),
    args = [],
    ipc,
    spinner,
    ...spawnOptions
  } = {
    __proto__: null,
    ...options
  };
  // Lazily access constants.ENV.NODE_COMPILE_CACHE
  const {
    NODE_COMPILE_CACHE
  } = constants.ENV;
  let stdio = spawnOptions.stdio;
  const useIpc = objects.isObject(ipc);
  // Include 'ipc' in the spawnOptions.stdio when an options.ipc object is provided.
  // See https://github.com/nodejs/node/blob/v23.6.0/lib/child_process.js#L161-L166
  // and https://github.com/nodejs/node/blob/v23.6.0/lib/internal/child_process.js#L238.
  if (typeof stdio === 'string') {
    stdio = useIpc ? [stdio, stdio, stdio, 'ipc'] : [stdio, stdio, stdio];
  } else if (useIpc && Array.isArray(stdio) && !stdio.includes('ipc')) {
    stdio = stdio.concat('ipc');
  }
  const useDebug = debug.isDebug();
  const terminatorPos = args.indexOf('--');
  const rawBinArgs = terminatorPos === -1 ? args : args.slice(0, terminatorPos);
  const progressArg = rawBinArgs.findLast(npm.isNpmProgressFlag) !== '--no-progress';
  const binArgs = rawBinArgs.filter(a => !npm.isNpmAuditFlag(a) && !npm.isNpmFundFlag(a) && !npm.isNpmProgressFlag(a));
  const otherArgs = terminatorPos === -1 ? [] : args.slice(terminatorPos);
  const isSilent = !useDebug && !binArgs.some(npm.isNpmLoglevelFlag);
  const logLevelArgs = isSilent ? ['--loglevel', 'silent'] : [];
  const spawnPromise = spawn.spawn(
  // Lazily access constants.execPath.
  constants.execPath, [
  // Lazily access constants.nodeHardenFlags.
  ...constants.nodeHardenFlags,
  // Lazily access constants.nodeNoWarningsFlags.
  ...constants.nodeNoWarningsFlags,
  // Lazily access constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD.
  ...(constants.ENV.INLINED_SOCKET_CLI_SENTRY_BUILD ? ['--require',
  // Lazily access constants.instrumentWithSentryPath.
  constants.instrumentWithSentryPath] : []), '--require',
  // Lazily access constants.shadowNpmInjectPath.
  constants.shadowNpmInjectPath, npm.resolveBinPathSync(agentExecPath), 'install',
  // Avoid code paths for 'audit' and 'fund'.
  '--no-audit', '--no-fund',
  // Add '--no-progress' to fix input being swallowed by the npm spinner.
  '--no-progress',
  // Add '--loglevel=silent' if a loglevel flag is not provided and the
  // SOCKET_CLI_DEBUG environment variable is not truthy.
  ...logLevelArgs, ...binArgs, ...otherArgs], {
    spinner,
    ...spawnOptions,
    stdio,
    env: {
      ...process.env,
      ...(NODE_COMPILE_CACHE ? {
        NODE_COMPILE_CACHE
      } : undefined),
      ...spawnOptions.env
    }
  });
  if (useIpc) {
    spawnPromise.process.send({
      [SOCKET_IPC_HANDSHAKE]: {
        [SOCKET_CLI_SAFE_BIN]: NPM$2,
        [SOCKET_CLI_SAFE_PROGRESS]: progressArg,
        ...ipc
      }
    });
  }
  return spawnPromise;
}

const {
  NPM: NPM$1,
  PNPM: PNPM$1
} = constants;
function runAgentInstall(pkgEnvDetails, options) {
  const {
    agent,
    agentExecPath
  } = pkgEnvDetails;
  // All package managers support the "install" command.
  if (agent === NPM$1) {
    return safeNpmInstall({
      agentExecPath,
      ...options
    });
  }
  const {
    args = [],
    spinner,
    ...spawnOptions
  } = {
    __proto__: null,
    ...options
  };
  const skipNodeHardenFlags = agent === PNPM$1 && pkgEnvDetails.agentVersion.major < 11;
  return spawn.spawn(agentExecPath, ['install', ...args], {
    // Lazily access constants.WIN32.
    shell: constants.WIN32,
    spinner,
    stdio: 'inherit',
    ...spawnOptions,
    env: {
      ...process.env,
      NODE_OPTIONS: cmdFlagsToString([...(skipNodeHardenFlags ? [] :
      // Lazily access constants.nodeHardenFlags.
      constants.nodeHardenFlags),
      // Lazily access constants.nodeNoWarningsFlags.
      ...constants.nodeNoWarningsFlags]),
      ...spawnOptions.env
    }
  });
}

async function spawnCoana(args, options, extra) {
  const {
    env: optionsEnv
  } = {
    __proto__: null,
    ...options
  };
  try {
    const output = await spawn.spawn(constants.execPath, [
    // Lazily access constants.nodeNoWarningsFlags.
    ...constants.nodeNoWarningsFlags,
    // Lazily access constants.coanaBinPath.
    constants.coanaBinPath, ...args], {
      ...options,
      env: {
        ...process.env,
        ...optionsEnv,
        SOCKET_CLI_API_BASE_URL: constants.ENV.SOCKET_CLI_API_BASE_URL || undefined,
        SOCKET_CLI_API_TOKEN: getDefaultToken()
      }
    }, extra);
    return {
      ok: true,
      data: output.stdout
    };
  } catch (e) {
    const stderr = e?.stderr;
    const message = stderr ? stderr : e?.message;
    return {
      ok: false,
      data: e,
      message
    };
  }
}

const {
  BINARY_LOCK_EXT,
  BUN,
  HIDDEN_PACKAGE_LOCK_JSON,
  LOCK_EXT,
  NPM,
  NPM_BUGGY_OVERRIDES_PATCHED_VERSION,
  PACKAGE_JSON,
  PNPM,
  VLT,
  YARN,
  YARN_BERRY,
  YARN_CLASSIC
} = constants;
const AGENTS = [BUN, NPM, PNPM, YARN_BERRY, YARN_CLASSIC, VLT];
const binByAgent = new Map([[BUN, BUN], [NPM, NPM], [PNPM, PNPM], [YARN_BERRY, YARN], [YARN_CLASSIC, YARN], [VLT, VLT]]);
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (...args) => {
      try {
        return await reader(...args);
      } catch {}
      return undefined;
    };
  }
  const binaryReader = wrapReader(readFileBinary);
  const defaultReader = wrapReader(async lockPath => await readFileUtf8(lockPath));
  return new Map([[BUN, wrapReader(async (lockPath, agentExecPath, cwd = process.cwd()) => {
    const ext = path.extname(lockPath);
    if (ext === LOCK_EXT) {
      return await defaultReader(lockPath);
    }
    if (ext === BINARY_LOCK_EXT) {
      const lockBuffer = await binaryReader(lockPath);
      if (lockBuffer) {
        try {
          return vendor.hyrious__bun_lockbExports.parse(lockBuffer);
        } catch {}
      }
      // To print a Yarn lockfile to your console without writing it to disk
      // use `bun bun.lockb`.
      // https://bun.sh/guides/install/yarnlock
      return (await spawn.spawn(agentExecPath, [lockPath], {
        cwd,
        // Lazily access constants.WIN32.
        shell: constants.WIN32
      })).stdout;
    }
    return undefined;
  })], [NPM, defaultReader], [PNPM, defaultReader], [VLT, defaultReader], [YARN_BERRY, defaultReader], [YARN_CLASSIC, defaultReader]]);
})();

// The order of LOCKS properties IS significant as it affects iteration order.
const LOCKS = {
  [`bun${LOCK_EXT}`]: BUN,
  [`bun${BINARY_LOCK_EXT}`]: BUN,
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  'npm-shrinkwrap.json': NPM,
  'package-lock.json': NPM,
  'pnpm-lock.yaml': PNPM,
  'pnpm-lock.yml': PNPM,
  [`yarn${LOCK_EXT}`]: YARN_CLASSIC,
  'vlt-lock.json': VLT,
  // Lastly, look for a hidden lock file which is present if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  'node_modules/.package-lock.json': NPM
};
async function getAgentExecPath(agent) {
  const binName = binByAgent.get(agent);
  if (binName === NPM) {
    // Lazily access constants.npmExecPath.
    return constants.npmExecPath;
  }
  return (await vendor.libExports$1(binName, {
    nothrow: true
  })) ?? binName;
}
async function getAgentVersion(agentExecPath, cwd) {
  let result;
  try {
    result =
    // Coerce version output into a valid semver version by passing it through
    // semver.coerce which strips leading v's, carets (^), comparators (<,<=,>,>=,=),
    // and tildes (~).
    vendor.semverExports.coerce(
    // All package managers support the "--version" flag.

    (await spawn.spawn(agentExecPath, ['--version'], {
      cwd,
      // Lazily access constants.WIN32.
      shell: constants.WIN32
    })).stdout) ?? undefined;
  } catch (e) {
    debug.debugFn('catch: unexpected\n', e);
  }
  return result;
}
async function detectPackageEnvironment({
  cwd = process.cwd(),
  onUnknown
} = {}) {
  let lockPath = await findUp(Object.keys(LOCKS), {
    cwd
  });
  let lockName = lockPath ? path.basename(lockPath) : undefined;
  const isHiddenLockFile = lockName === HIDDEN_PACKAGE_LOCK_JSON;
  const pkgJsonPath = lockPath ? path.resolve(lockPath, `${isHiddenLockFile ? '../' : ''}../${PACKAGE_JSON}`) : await findUp(PACKAGE_JSON, {
    cwd
  });
  const pkgPath = pkgJsonPath && fs.existsSync(pkgJsonPath) ? path.dirname(pkgJsonPath) : undefined;
  const editablePkgJson = pkgPath ? await packages.readPackageJson(pkgPath, {
    editable: true
  }) : undefined;
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = strings.isNonEmptyString(editablePkgJson?.content?.packageManager) ? editablePkgJson.content.packageManager : undefined;
  let agent;
  if (pkgManager) {
    // A valid "packageManager" field value is "<package manager name>@<version>".
    // https://nodejs.org/api/packages.html#packagemanager
    const atSignIndex = pkgManager.lastIndexOf('@');
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex);
      const version = pkgManager.slice(atSignIndex + 1);
      if (version && AGENTS.includes(name)) {
        agent = name;
      }
    }
  }
  if (agent === undefined && !isHiddenLockFile && typeof pkgJsonPath === 'string' && typeof lockName === 'string') {
    agent = LOCKS[lockName];
  }
  if (agent === undefined) {
    agent = NPM;
    onUnknown?.(pkgManager);
  }
  const agentExecPath = await getAgentExecPath(agent);
  const agentVersion = await getAgentVersion(agentExecPath, cwd);
  if (agent === YARN_CLASSIC && (agentVersion?.major ?? 0) > 1) {
    agent = YARN_BERRY;
  }
  // Lazily access constants.maintainedNodeVersions.
  const {
    maintainedNodeVersions
  } = constants;
  // Lazily access constants.minimumVersionByAgent.
  const minSupportedAgentVersion = constants.minimumVersionByAgent.get(agent);
  const minSupportedNodeVersion = maintainedNodeVersions.last;
  const nodeVersion = vendor.semverExports.coerce(process.version);
  let lockSrc;
  let pkgAgentRange;
  let pkgNodeRange;
  let pkgMinAgentVersion = minSupportedAgentVersion;
  let pkgMinNodeVersion = minSupportedNodeVersion;
  if (editablePkgJson?.content) {
    const {
      engines
    } = editablePkgJson.content;
    const engineAgentRange = engines?.[agent];
    const engineNodeRange = engines?.['node'];
    if (strings.isNonEmptyString(engineAgentRange)) {
      pkgAgentRange = engineAgentRange;
      // Roughly check agent range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgAgentRange);
      if (coerced && vendor.semverExports.lt(coerced, pkgMinAgentVersion)) {
        pkgMinAgentVersion = coerced.version;
      }
    }
    if (strings.isNonEmptyString(engineNodeRange)) {
      pkgNodeRange = engineNodeRange;
      // Roughly check Node range as semver.coerce will strip leading
      // v's, carets (^), comparators (<,<=,>,>=,=), and tildes (~).
      const coerced = vendor.semverExports.coerce(pkgNodeRange);
      if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
        pkgMinNodeVersion = coerced.version;
      }
    }
    const browserslistQuery = editablePkgJson.content['browserslist'];
    if (Array.isArray(browserslistQuery)) {
      // List Node targets in ascending version order.
      const browserslistNodeTargets = vendor.browserslistExports(browserslistQuery).filter(v => /^node /i.test(v)).map(v => v.slice(5 /*'node '.length*/)).sort(sorts.naturalCompare);
      if (browserslistNodeTargets.length) {
        // browserslistNodeTargets[0] is the lowest Node target version.
        const coerced = vendor.semverExports.coerce(browserslistNodeTargets[0]);
        if (coerced && vendor.semverExports.lt(coerced, pkgMinNodeVersion)) {
          pkgMinNodeVersion = coerced.version;
        }
      }
    }
    lockSrc = typeof lockPath === 'string' ? await readLockFileByAgent.get(agent)(lockPath, agentExecPath, cwd) : undefined;
  } else {
    lockName = undefined;
    lockPath = undefined;
  }
  // Does the system agent version meet our minimum supported agent version?
  const agentSupported = !!agentVersion && vendor.semverExports.satisfies(agentVersion, `>=${minSupportedAgentVersion}`);

  // Does the system Node version meet our minimum supported Node version?
  const nodeSupported = vendor.semverExports.satisfies(nodeVersion, `>=${minSupportedNodeVersion}`);
  const npmExecPath = agent === NPM ? agentExecPath : await getAgentExecPath(NPM);
  const npmBuggyOverrides = agent === NPM && !!agentVersion && vendor.semverExports.lt(agentVersion, NPM_BUGGY_OVERRIDES_PATCHED_VERSION);
  return {
    agent,
    agentExecPath,
    agentSupported,
    agentVersion,
    editablePkgJson,
    features: {
      npmBuggyOverrides
    },
    lockName,
    lockPath,
    lockSrc,
    nodeSupported,
    nodeVersion,
    npmExecPath,
    pkgPath,
    pkgRequirements: {
      agent: pkgAgentRange ?? `>=${pkgMinAgentVersion}`,
      node: pkgNodeRange ?? `>=${pkgMinNodeVersion}`
    },
    pkgSupports: {
      // Does our minimum supported agent version meet the package's requirements?
      agent: vendor.semverExports.satisfies(minSupportedAgentVersion, `>=${pkgMinAgentVersion}`),
      // Does our supported Node versions meet the package's requirements?
      node: maintainedNodeVersions.some(v => vendor.semverExports.satisfies(v, `>=${pkgMinNodeVersion}`))
    }
  };
}
async function detectAndValidatePackageEnvironment(cwd, options) {
  const {
    cmdName = '',
    logger,
    prod
  } = {
    __proto__: null,
    ...options
  };
  const details = await detectPackageEnvironment({
    cwd,
    onUnknown(pkgManager) {
      logger?.warn(cmdPrefixMessage(cmdName, `Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`));
    }
  });
  const {
    agent,
    nodeVersion,
    pkgRequirements
  } = details;
  const agentVersion = details.agentVersion ?? 'unknown';
  if (!details.agentSupported) {
    const minVersion = constants.minimumVersionByAgent.get(agent);
    return {
      ok: false,
      message: 'Version Mismatch',
      cause: cmdPrefixMessage(cmdName, `Requires ${agent} >=${minVersion}. Current version: ${agentVersion}.`)
    };
  }
  if (!details.nodeSupported) {
    const minVersion = constants.maintainedNodeVersions.last;
    return {
      ok: false,
      message: 'Version Mismatch',
      cause: cmdPrefixMessage(cmdName, `Requires Node >=${minVersion}. Current version: ${nodeVersion}.`)
    };
  }
  if (!details.pkgSupports.agent) {
    return {
      ok: false,
      message: 'Engine Mismatch',
      cause: cmdPrefixMessage(cmdName, `Package engine "${agent}" requires ${pkgRequirements.agent}. Current version: ${agentVersion}`)
    };
  }
  if (!details.pkgSupports.node) {
    return {
      ok: false,
      message: 'Version Mismatch',
      cause: cmdPrefixMessage(cmdName, `Package engine "node" requires ${pkgRequirements.node}. Current version: ${nodeVersion}`)
    };
  }
  const lockName = details.lockName ?? 'lock file';
  if (details.lockName === undefined || details.lockSrc === undefined) {
    return {
      ok: false,
      message: 'Missing Lock File',
      cause: cmdPrefixMessage(cmdName, `No ${lockName} found`)
    };
  }
  if (details.lockSrc.trim() === '') {
    return {
      ok: false,
      message: 'Empty Lock File',
      cause: cmdPrefixMessage(cmdName, `${lockName} is empty`)
    };
  }
  if (details.pkgPath === undefined) {
    return {
      ok: false,
      message: 'Missing package.json',
      cause: cmdPrefixMessage(cmdName, `No ${PACKAGE_JSON} found`)
    };
  }
  if (prod && (agent === BUN || agent === YARN_BERRY)) {
    return {
      ok: false,
      message: 'Bad input',
      cause: cmdPrefixMessage(cmdName, `--prod not supported for ${agent}${agentVersion ? `@${agentVersion}` : ''}`)
    };
  }
  if (details.lockPath && path.relative(cwd, details.lockPath).startsWith('.')) {
    // Note: In tests we return <redacted> because otherwise snapshots will fail.
    const {
      REDACTED
    } = constants;
    // Lazily access constants.ENV.VITEST.
    const redacting = constants.ENV.VITEST;
    logger?.warn(cmdPrefixMessage(cmdName, `Package ${lockName} found at ${redacting ? REDACTED : details.lockPath}`));
  }
  return {
    ok: true,
    data: details
  };
}

const COMPLETION_CMD_PREFIX = 'complete -F _socket_completion';
function getCompletionSourcingCommand() {
  // Note: this is exported to distPath in .config/rollup.dist.config.mjs
  const completionScriptExportPath = path.join(
  // Lazily access constants.distPath.
  constants.distPath, 'socket-completion.bash');
  if (!fs.existsSync(completionScriptExportPath)) {
    return {
      ok: false,
      message: 'Tab Completion script not found',
      cause: `Expected to find completion script at \`${completionScriptExportPath}\` but it was not there`
    };
  }
  return {
    ok: true,
    data: `source ${completionScriptExportPath}`
  };
}
function getBashrcDetails(targetCommandName) {
  const sourcingCommand = getCompletionSourcingCommand();
  if (!sourcingCommand.ok) {
    return sourcingCommand;
  }

  // Lazily access constants.socketAppDataPath.
  const {
    socketAppDataPath
  } = constants;
  if (!socketAppDataPath) {
    return {
      ok: false,
      message: 'Could not determine config directory',
      cause: 'Failed to get config path'
    };
  }

  // _socket_completion is the function defined in our completion bash script
  const completionCommand = `${COMPLETION_CMD_PREFIX} ${targetCommandName}`;

  // Location of completion script in config after installing
  const completionScriptPath = path.join(path.dirname(socketAppDataPath), 'completion', 'socket-completion.bash');
  const bashrcContent = `# Socket CLI completion for "${targetCommandName}"
if [ -f "${completionScriptPath}" ]; then
    # Load the tab completion script
    source "${completionScriptPath}"
    # Tell bash to use this function for tab completion of this function
    ${completionCommand}
fi
`;
  return {
    ok: true,
    data: {
      sourcingCommand: sourcingCommand.data,
      completionCommand,
      toAddToBashrc: bashrcContent,
      targetName: targetCommandName,
      targetPath: completionScriptPath
    }
  };
}

exports.AuthError = AuthError;
exports.COMPLETION_CMD_PREFIX = COMPLETION_CMD_PREFIX;
exports.InputError = InputError;
exports.RangeStyles = RangeStyles;
exports.applyRange = applyRange;
exports.captureException = captureException;
exports.checkCommandInput = checkCommandInput;
exports.cmdFlagValueToArray = cmdFlagValueToArray;
exports.cmdFlagsToString = cmdFlagsToString;
exports.cmdPrefixMessage = cmdPrefixMessage;
exports.commonFlags = commonFlags;
exports.createEnum = createEnum;
exports.detectAndValidatePackageEnvironment = detectAndValidatePackageEnvironment;
exports.determineOrgSlug = determineOrgSlug;
exports.extractOverridesFromPnpmLockSrc = extractOverridesFromPnpmLockSrc;
exports.failMsgWithBadge = failMsgWithBadge;
exports.getAlertsMapFromPnpmLockfile = getAlertsMapFromPnpmLockfile;
exports.getAlertsMapFromPurls = getAlertsMapFromPurls;
exports.getBashrcDetails = getBashrcDetails;
exports.getConfigValue = getConfigValue;
exports.getConfigValueOrUndef = getConfigValueOrUndef;
exports.getCveInfoFromAlertsMap = getCveInfoFromAlertsMap;
exports.getFlagListOutput = getFlagListOutput;
exports.getMajor = getMajor;
exports.getMinVersion = getMinVersion;
exports.getNpmBinPath = getNpmBinPath;
exports.getNpmRequire = getNpmRequire;
exports.getNpxBinPath = getNpxBinPath;
exports.getOutputKind = getOutputKind;
exports.getPackageFilesForScan = getPackageFilesForScan;
exports.getPkgFullNameFromPurl = getPkgFullNameFromPurl;
exports.getPurlObject = getPurlObject;
exports.getSocketDevPackageOverviewUrlFromPurl = getSocketDevPackageOverviewUrlFromPurl;
exports.getVisibleTokenPrefix = getVisibleTokenPrefix;
exports.globWorkspace = globWorkspace;
exports.handleApiCall = handleApiCall;
exports.handleApiCallNoSpinner = handleApiCallNoSpinner;
exports.hasDefaultToken = hasDefaultToken;
exports.idToNpmPurl = idToNpmPurl;
exports.idToPurl = idToPurl;
exports.isHelpFlag = isHelpFlag;
exports.isNpmBinPathShadowed = isNpmBinPathShadowed;
exports.isNpxBinPathShadowed = isNpxBinPathShadowed;
exports.isReadOnlyConfig = isReadOnlyConfig;
exports.logAlertsMap = logAlertsMap;
exports.mapToObject = mapToObject;
exports.mdTable = mdTable;
exports.mdTableOfPairs = mdTableOfPairs;
exports.mdTableStringNumber = mdTableStringNumber;
exports.meowOrExit = meowOrExit;
exports.meowWithSubcommands = meowWithSubcommands;
exports.msAtHome = msAtHome;
exports.npa = npa;
exports.outputFlags = outputFlags;
exports.parsePnpmLockfile = parsePnpmLockfile;
exports.parsePnpmLockfileVersion = parsePnpmLockfileVersion;
exports.queryApiSafeJson = queryApiSafeJson;
exports.queryApiSafeText = queryApiSafeText;
exports.readLockfile = readLockfile;
exports.readOrDefaultSocketJson = readOrDefaultSocketJson;
exports.readSocketJson = readSocketJson;
exports.removeNodeModules = removeNodeModules;
exports.runAgentInstall = runAgentInstall;
exports.safeReadFile = safeReadFile;
exports.safeReadFileSync = safeReadFileSync;
exports.safeStatsSync = safeStatsSync;
exports.sensitiveConfigKeys = sensitiveConfigKeys;
exports.serializeResultJson = serializeResultJson;
exports.setupSdk = setupSdk;
exports.spawnCoana = spawnCoana;
exports.suggestOrgSlug = suggestOrgSlug;
exports.supportedConfigKeys = supportedConfigKeys;
exports.tildify = tildify;
exports.updateConfigValue = updateConfigValue;
exports.walkNestedMap = walkNestedMap;
exports.writeSocketJson = writeSocketJson;
//# debugId=738e476d-5a8a-49d7-a6be-c50b9907d6f1
//# sourceMappingURL=utils.js.map
